package SBV::Colors;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Creat time: 2013-05-14 10:21:04       |
#------------------------------------------------+
=pod

=head1 Name

SBV::Colors

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-05-14 10:21:04

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT    = qw(load_colors fetch_color fetch_rainbow_color rainbow);
#our @EXPORT_OK = qw( );

use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../";
use SBV;
use SBV::DEBUG;

sub load_colors
{
	my $colorsH = shift;
	my $colors;

	foreach my$name (keys %$colorsH)
	{
		$colorsH->{$name} = $colorsH->{$colorsH->{$name}} if ($colorsH->{$colorsH->{$name}});
		$colors->{$name} = hex_rgb($colorsH->{$name});
	}

	return $colors;
}

sub fetch_color
{
	my $name = lc shift;

	if ($SBV::colors->{$name})
	{
		$name = $SBV::colors->{$name};
	}
	
	$name = hex_rgb($name);

	if ($name =~ /^#/)
	{
		return $name;
	}
	elsif ($name eq "none")
	{
		return $name;
	}
	else
	{
		ERROR('color_format_err',$name);
	}
}

sub fetch_gradient_color
{
	my ($ratio,@colors) = @_;

	return $colors[0] if ($ratio < 0);
	return $colors[-1] if ($ratio >= 1);
	
	my $start = int ($#colors * $ratio);
	my $stop = $start + 1;

	my @sta = hex2rgb($colors[$start]);
	my @end = hex2rgb($colors[$stop]);
	my @newRGB = map { $sta[$_] + ($#colors*$ratio-$start) * ($end[$_]-$sta[$_]) } 0 .. 2;

	my $color = join "," , @newRGB;
	$color = hex_rgb($color);
	
	return $color;
}

sub hex2rgb
{
	my $hex = shift;
	my @rgb = $hex =~ /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
	@rgb = map { hex($_) } @rgb;

	return @rgb;
}

sub isColor
{
	foreach (@_)
	{
		my $name = lc $_;
		my $f = 0;
		
		if ($SBV::colors->{$name})
		{
			$f = 1;	
		}

		$name = hex_rgb($name);

		if ($name =~ /^#/ || $name eq "none")
		{
			$f = 1;	
		}

		return 0 if ($f == 0);
	}

	return 1;
}

#===  FUNCTION  ================================================================
#         NAME: fetch_rainbow_color
#      PURPOSE: fetch colors according rainbow formula 
#   PARAMETERS: ????
#      RETURNS: ????
#  DESCRIPTION: ????
#       THROWS: no exceptions
#     COMMENTS: none
#     SEE ALSO: n/a
#===============================================================================
sub fetch_rainbow_color
{
	my @param = split /[\,\s]+/ , $_[0];
	
	my $sum = shift @param;
	my ($sta,$num);

	if ($#param == 0)
	{
		$sta = 1;
		$num = $param[0];
	}
	elsif ($#param == 1)
	{
		$sta = $param[0];
		$num = $param[1];
	}

	my @colors = rainbow($sum);
	my @res = map {	$colors[$_ + $sta-1] } 0 .. $num - 1;
	return @res;
}

sub hex_rgb
{
	my $val = lc shift;

	if ($val =~ /^[0-9A-F]{3}$/i)
	{
		my @temp = split // , $val;
		@temp = map { $_.$_ } @temp;
		my $temp = join "" , @temp;
		return "#$temp";
	}
	elsif ($val =~ /^[0-9A-F]{6}$/i)
	{
		return "#" . $val;
	}
	elsif ($val =~ /^([\d\.]+),([\d\.]+),([\d\.]+)$/ || $val =~ /^rgb\(([\d\.]+),([\d\.]+),([\d\.]+)\)$/i)
	{
		return "#" . dec2hex($1) . dec2hex($2) . dec2hex($3);
	}
	elsif ($val =~ /^hsv\((\d+),(\d+),(\d+)\)$/)
	{
		return hsv2hexRGB($1,$2,$3);
	}
	else
	{
		return $val;
	}
}

# turn decimal 
sub dec2hex
{
	my $dec = shift;

	# check the RGB value is between 0-255 or not
	if ($dec < 0 || $dec > 255)
	{
		WARN("rgb value is overflow: ","$dec");
		$dec = $dec < 0 ? 0 : 255;
	}

	# the RGB value is between 0-1
	elsif ($dec >= 0 && $dec <= 1)
	{
		$dec = int ($dec * 255);
	}

	my $hex = sprintf("%x",$dec);
	my $len = length $hex;
	
	$hex = "0$hex" if ($len == 1);

	return $hex;
}

sub hsv2hexRGB
{
	my ($h, $s, $v) = @_;
	my @rgb;

	$h = $h % 360 if $h < 0 || $h > 360;
	$h /= 60;

	my $i = POSIX::floor( $h );
	my $f = $h - $i;
	my $p = $v * ( 1 - $s );
	my $q = $v * ( 1 - $s * $f );
	my $t = $v * ( 1 - $s * ( 1 - $f ) );

	if ($i == 0) {
		@rgb = ($v,$t,$p);
	} elsif ($i == 1) {
		@rgb = ($q,$v,$p);
	} elsif ($i == 2) {
		@rgb = ($p,$v,$t);
	} elsif ($i == 3) {
		@rgb = ($p,$q,$v);
	} elsif ($i == 4) {
		@rgb = ($t,$p,$v);
	} else {
		@rgb = ($v,$p,$q);
	}

	@rgb = map { dec2hex($_) } @rgb;
	
	return "#" . $rgb[0] . $rgb[1] . $rgb[2];
}

#===  FUNCTION  ================================================================
#         NAME: rainbow
#      PURPOSE: re-build the funtion rainbow of R to get a contiguous hsv color
#   PARAMETERS: rainbow(n, s = 1, v = 1, start = 0, end = max(1,n - 1)/n) 
#      RETURNS: contiguous colors array
#  DESCRIPTION: 'n' is the color num
#       THROWS: no exceptions
#     COMMENTS: detail is in R funtion 'rainbow' help info
#     SEE ALSO: n/a
#===============================================================================
sub rainbow
{
	my $num = shift; # >=1
	my %param = @_;
	
	my $s = $param{s} || 1; 
	my $v = $param{v} || 1;
	my $start = $param{start} || 0; # a number in [0,1]

	my $default_end = ($num-1) > 1 ? ($num-1)/$num : 1/$num;

	my $end = $param{end} || $default_end; # a number in [0,1]
	
	if (0 == $num)
	{
		return (hsv2hexRGB($start*360,$s,$v));
	}
	elsif ($num >= 1)
	{
		my @col;
		my $step = ($end - $start)/$num;

		for (my$i=$start; $i<$end; $i+=$step)
		{
			push @col , hsv2hexRGB($i*360,$s,$v);
		}

		return @col;
	}
	else
	{
		ERROR('rainbow_num_err',$num);
	}
}

# set gradient color 
sub gradient
{
	my ($colors,%param) = @_;
	my $id = "color$SBV::idnum";
	$SBV::idnum ++;
	my $type = $param{'-type'} || "linear";
	my $orient = $param{'-orient'} || "right";
	
	my $unit = 1/($#$colors);

	my %par;
	if ($orient eq "top")
	{
		%par = (x1=>1,y1=>1,x2=>1,y2=>0); 	
	}
	elsif ($orient eq "left")
	{
		%par = (x1=>1,y1=>1,x2=>0,y2=>1); 	
	}
	else 
	{
		%par = (x1=>0,y1=>1,x2=>1,y2=>1); 	
	}

	$par{id} = $id;
	$par{'-type'} = $type;

	my $linear = $SBV::defs->gradient(%par);
	foreach ( 0 .. $#$colors ){	$linear->stop('stop-color'=>$colors->[$_],offset=>$_*$unit); }

	return "url(\#$id)";
}
