package SBV::STONE::AXIS;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Creat time: 2013-05-31 11:15:29       |
#------------------------------------------------+
=pod

=head1 Name

SBV::STONE::AXIS

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-05-31 11:15:29

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);

use Math::Round;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../";
use lib "$FindBin::RealBin/lib/";
use lib "$FindBin::RealBin/../lib";

use SBV::STAT;
use SBV::DEBUG;

#-------------------------------------------------------------------------------
#  name: new
#  func: create new axis object
#-------------------------------------------------------------------------------
sub new 
{
	my $class = shift;
	my $axis = {};
	my %param = @_;

	do_init_feature($axis);
	
	bless $axis , $class;
	$axis->feature(%param);
	return $axis;
}

#-------------------------------------------------------------------------------
#  name: doInitFeature
#  func: set the default feature for axis
#-------------------------------------------------------------------------------
sub do_init_feature
{
	my %feature = (
		# ox , oy , length => must be defined 
		show        => 1,
		angle       => 0,
		thickness   => 0,
		
		bone        => 0,
		tail        => 0, # the bone tail marker
		
		tick        => undef, # no draw tick/scale
		side        => "right", # right(outter) / left(inner)
		start       => 0.2, # 0 - 1 units
		
		show_tick_line  => 1, # draw ticks line or not
		size        => 8, # main ticks line length
		
		show_tick_label => 1,
		ticktext    => undef, # defined specific ticks text
		multiple    => 1,
		translate   => 0, # 0 - 1 units / general is 0.5 (for string ticks)

		theme       => undef, # the ticks text theme
		bgline      => 0, # draw background line or not

		labels      => undef, # add specific labels
		labels_theme => undef, 
		
		skip_first_tick => 1,
		skip_last_tick => 1,

		unit_label => "",
	);
	my $axis = shift;
	feature($axis,%feature);
}


#-------------------------------------------------------------------------------
#  name: check_features
#  func: check the needed feature was defined or not 
#        check the features were defined correctly or not
#-------------------------------------------------------------------------------
sub check_features
{
	my $self = shift;
	
	ERROR('axis_point_coord_err') unless (defined $self->{ox} && defined $self->{oy});
	ERROR('axis_length_err') unless (defined $self->{length});
	ERROR('axis_parent_err') unless (defined $self->{parent});
	# you can add other checks here 

	return 1;
}

#-------------------------------------------------------------------------------
#  name: feature
#  func: set the parameter for axis
#-------------------------------------------------------------------------------
sub feature
{
	my $self = shift;
	my %param = @_;
	foreach my$key(keys %param)
	{
		$self->{$key} = $param{$key};	
	}
	return 1;
}

*aes = \&feature;

# draw the axis
sub plot
{
	my $self = shift;
	my %param = @_;
	$self->feature(%param);
	$self->check_features;
	
	# remove old axis group if exists
	$self->{parent}->removeChild($self->{group}) if (exists $self->{group});
	
	my ($ox,$oy) = ($self->{ox},$self->{oy});
	my $group = $self->{parent}->group(class=>"axis",transform=>"translate($ox,$oy)")->group();
	$group->setAttribute("transform","rotate($self->{angle})") if (my$angle = $self->{angle});
	$self->{group} = $group;
	$self->normal_axis;
	
	$self->{parent}->removeChild($self->{group}) unless($self->{show});
}

# draw normal axis
sub normal_axis
{
	my $self = shift;
	my $group = $self->{group} or die "the axis group is not defined!";
	
	# draw bone
	if ($self->{bone})
	{
		my $bone = $group->line(x1=>0,y1=>0,x2=>$self->{length},y2=>0,class=>"axis");
		
		if ($self->{tail})
		{
			my $markid = SBV::DRAW::arrow(2*$self->{size},$self->{size},-zh=>0.5,-class=>"arrow");
			$bone->setAttribute("marker-end","url(#$markid)");
		};
	}
	
	if (defined $self->{tick})
	{
		$self->normal_tick;	
	}
}

# add tick on axis
sub normal_tick
{
	my ($self,%param) = @_;
	my $group = $self->{group} or die "the axis group is not defined";
	
	$self->feature(%param);
	return unless (defined $self->{tick});
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# font 
	my $font = SBV::Font->new($self->{theme});
	my $tickH = $font->fetch_text_height;

	# deal the dividing
	my @temp = split /\s+/ , $self->{tick};
	my $subNum = int( pop @temp ) if ($#temp == 3);
	my ($min,$max,$window) = @temp;
	my $zoom = ($max - $min + $self->{start} * $window) / $self->{'length'};
	my $markNum = int (($max-$min)/$window);
	my $markRm = ($max - $min) / $window - $markNum;
	$markNum -- if ($markRm == 0 && $self->{translate} == 0 && $self->{skip_last_tick});
	my $subwin = $window / $subNum if ($subNum);
	
	$self->feature(zoom=>$zoom,unit=>1/$zoom,min=>$min,max=>$max,window=>$window);
	my $startX = nearest 0.001 , $self->{start} * $window / $zoom;
	
	# draw ticks
	my $start_item = 0;
	#$start_item = 1 if (0 == $self->{start} && 1 == $self->{skip_first_tick} && 0 == $self->{translate});
	$start_item = 1 if (0 == $self->{start} && 1 == $self->{skip_first_tick});
	#my $start_item = (0 == $self->{translate} && 0 != $self->{start}) ? 0 : 1;
	
	if (0 == $self->{show_tick_line})
	{
		$self->{size} = 0;
	}
	
	foreach my$i ( $start_item .. $markNum )
	{
		my $tickX = nearest 0.01 , $startX + $i*$window/$zoom;
		
		# draw tick line
		if (1 == $self->{show_tick_line})
		{
			my $tickY2 = $self->{side} eq "left" ? -$self->{size} : $self->{size};
			$group->line(x1=>$tickX,x2=>$tickX,y1=>0,y2=>$tickY2,class=>"tick")
		}
		
		# draw bg line
		if ($self->{bgline} > 0)
		{
			my $bglineY2 = $self->{side} eq "left" ? $self->{bgline} : - $self->{bgline};
			unless ($self->{start} == 0 && $i == 0)
			{
				$group->line(x1=>$tickX,x2=>$tickX,y1=>0,y2=>$bglineY2,class=>"bgline");
			}
		}
		
		# draw tick text 
		if ($self->{show_tick_label})
		{
			# fetch the tick label
			my $tick_val = defined $self->{ticktext} ? 
				$self->{ticktext}->[$i-1] : $min+$i*$window*$self->{multiple};
			$tick_val .= $self->{unit_label} if ($self->{unit_label});
			
			# fetch the tick label width
			my $textW = $font->fetch_text_width($tick_val);

			# fetch the tick label true size
			($textW,$tickH) = true_size($textW,$tickH,$font->{'font-angle'});

			# fetch the tick label y coord
			my $textY = $self->{side} eq "left" ? 
				0 - $self->{size} - $vi : 0 + $self->{size} + $tickH + $vi; 
			my $textX = nearest 0.01 , $tickX - $textW/2 - $self->{translate} * $window / $zoom;
			$textX = $textX + $textW if (defined $font->{'font-angle'} && $font->{'font-angle'} == -90);
			$textY = $textY - $tickH if (defined $font->{'font-angle'} && $font->{'font-angle'} == 90);
			my $text = SBV::DRAW::theme_text($group,$textX,$textY,$self->{theme},$tick_val);
			
			if ($self->{label_mirror})
			{
				my$matrix = SBV::DRAW::mirror($textX+$textW/2,0,$textX+$textW/2,1);
				$text->setAttribute('transform',$matrix);
			}

			if ($self->{label_angle})
			{
			}
		}

		# draw sub tick
		map {
			my $subtickY2 = $self->{side} eq "left" ? - $self->{size}/2 : $self->{size}/2;
			my $subtickX = $tickX + $_*$subwin/$zoom;
		} 1 .. $subNum - 1 if ($subNum && $subNum > 1 && $i != $markNum)
	}

	# add labels 
	my $labelFont = SBV::Font->new($self->{labels_theme});
	my $labelH = $labelFont->fetch_text_height;
	$tickH = 0 unless ( $self->{show_tick_label} ); 
	my $label_y = $self->{side} eq "left" ? 0 - $self->{size} - 2*$vi - $tickH : 0 + $self->{size} + $labelH + $tickH + 2*$vi;
	if ($self->{labels})	
	{
		foreach my$label (@{$self->{labels}})
		{
			my ($pos,$name) = @$label;
			my $labelW = $labelFont->fetch_text_width($name);
			my $x = $self->fetch_dis($pos);
			my $label_text = $group->text(x=>$x-$labelW/2,y=>$label_y)->cdata($name);
		}
	}
}

# draw circular axis
sub circle_axis
{
	
}

# add circle tick on axis
sub circle_tick
{
	
}

#-------------------------------------------------------------------------------
#  other functions for axis
#-------------------------------------------------------------------------------
# turn the true coordinate to the svg distance (the [input] to original point)
# the tick must be defined
sub fetch_dis
{
	my ($self,$rawval) = @_;
	return nearest (0.0001, ($rawval - $self->{min} + $self->{start}*$self->{window})*$self->{unit});
}

sub fetch_coord
{
	my ($self,$val) = @_;
	return $self->{ox} + $self->fetch_dis($val);
}

sub thickness
{
	my $self = shift;
	my %param = %$self;

	my $thickness = 0;
	my $tick = $param{tick};
	my $size = $param{size} || 8;
	my $len = $param{length};
	my $ticktext = $param{ticktext};

	return $thickness unless ($tick);
	
	$thickness += $size if($param{show_tick_line});
	
	my $tickFont = SBV::Font->new($param{theme});
	my $tickH = $tickFont->fetch_text_height;
	
	if ($param{theme})
	{
			
	}

	my $vi = $SBV::conf->{vspace} || 4;

	# dividing
	my @temp = split /\s+/ , $tick;
	my $subNum = int( pop @temp ) if ($#temp == 3);
	my ($min,$max,$window) = @temp;
	my $tickNum = int (($max-$min)/$window); # tick number
	
	my @tickVal;
	if (defined $param{ticktext})
	{
		@tickVal = @{$param{ticktext}};
	}
	else
	{
		@tickVal = map { $_*$window+$min } 0 .. $tickNum;
		shift @tickVal unless (0 == $param{translate});
		@tickVal = map { $_*$param{multiple}} 0 .. $#tickVal if (defined $param{multiple});
	}
	
	my $tickW = $tickFont->fetch_max_text_width(\@tickVal);
	$thickness += $vi + $tickH if ($param{show_tick_label});
	
	# labels 
	my $labelFont = SBV::Font->new($param{labels_theme});
	my $labelH = $labelFont->fetch_text_height;
	$thickness += 2*$vi + $labelH if ($param{labels});

	$self->{thickness} = $thickness;
	return $thickness;
}
