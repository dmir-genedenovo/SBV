package SBV::IMAGE::TREE;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-09-05 10:38:31     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::TREE

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-09-05 10:38:31

=cut

use strict;
use warnings;
require Exporter;

use Bio::TreeIO;
use FindBin;
use Math::Round;

use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::DEBUG;
use SBV::STAT;
use SBV::Constants;

sub new 
{
	my ($class,$file,$conf) = @_;
	my $treev = {};
	
	# load tree file 
	my $tree = _load_tree($file,$conf);
	my $id_trans = _load_ids($tree);
	$treev->{tree} = $tree;
	$treev->{conf} = $conf;
	$treev->{id_trans} = $id_trans;
	$conf->{align} = 1 if (! defined $conf->{align});

	bless $treev , $class;
	return $treev;
}

# load the tree file and set the outgroup
# if the outgroup is not exists witll use the default outgroup
sub _load_tree
{
	my ($file,$conf) = @_;
	my $format = $conf->{format};
	
	my $treeio = Bio::TreeIO->new('-format'=>$format,-file=>$file);
	my $tree = $treeio->next_tree;
	my @leaves = $tree->get_leaf_nodes;

	if ($conf->{'outgroup'} && $conf->{'outgroup'} ne $leaves[0]->id)
	{
		foreach my$leaf(@leaves)
		{
			# re define the outgroup and re build the tree
			if ($leaf->id eq $conf->{'outgroup'})
			{
				return reroot_tree($tree,$leaf);
			}
		}

		WARN('the outgroup name is not exists in the tree file!',$conf->{'outgroup'});
	}
	
	return $tree;	
}

# load the id and internal id
sub _load_ids
{
	my $tree = shift;
	my @leaves = $tree->get_leaf_nodes;
	my $trans = {};

	foreach my$leaf (@leaves)
	{
		$trans->{$leaf->id} = $leaf;	
	}

	return $trans;
}

# draw tree graph
sub plot
{
	my ($self,$parent) = @_;
	my $tree = $self->{tree};
	my $conf = $self->{conf};
	
	$conf->{model} = "normal" if (! exists $conf->{model});
	SBV::DRAW::background($conf,$parent);
	my $group = $parent->group(id=>"tree$SBV::idnum");
	$SBV::idnum ++;
	
	my %func = ("normal"=>\&normal_tree,circular=>\&circular_tree,
		"inverted_circular"=>\&inverted_circular_tree,unrooted=>\&unrooted_tree);

	&{$func{$conf->{model}}}($self,$tree,$conf,$group);
	
	# add legend
	if ($conf->{legend})
	{
		my $legend = SBV::STONE::LEGEND->new(conf=>$conf->{legend});
		$legend->location($conf);
		$legend->draw($parent);
	}
	
}

#-------------------------------------
# draw the normal tree 
#-------------------------------------
sub normal_tree
{
	my ($self,$tree,$conf,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	my $axis_flag = 0;
	foreach my$dataset(@datasets)
	{
		if ($dataset->{type} eq "bar" || $dataset->{type} eq "boxplot")
		{
			$axis_flag = 1;
			last;
		}
	}

	# set the width and height for the tree figure
	my $treeFW = $conf->{tw};
	my $treeFH = $conf->{th};
	my $x = $conf->{ox};
	my $y = $conf->{oty};
	my $cx = $conf->{ox} + $treeFW/2;
	my $cy = $conf->{oty} + $treeFH/2;
	
	if ($conf->{oriental} eq "top")
	{
		$group->setAttribute("transform","rotate(90,$cx,$cy)");
		($treeFW,$treeFH) = ($treeFH,$treeFW);
		$x = $cx - $treeFW/2;
		$y = $cy - $treeFH/2;
	}
	elsif ($conf->{oriental} eq "right")
	{
		my $matrix = SBV::DRAW::mirror($cx,$cy,$cx,0);
		$group->setAttribute("transform",$matrix);
	}
	elsif ($conf->{oriental} eq "bottom")
	{
		my $matrix = SBV::DRAW::mirror(0,$cy);
		$group->setAttribute("transform","rotate(-90,$cx,$cy)");
		($treeFW,$treeFH) = ($treeFH,$treeFW);
		$x = $cx - $treeFW/2;
		$y = $cy - $treeFH/2;
	}

	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}
	
	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	# the root tail length
	my $tail = $conf->{tail} || 10;
	ERROR("negative_length_err",$tail) if ($tail < 0);

	my $unit = $conf->{unit} || 0.01;
	my $treeL = tree_length($rootNode,$conf);
	my @leaves = $tree->get_leaf_nodes;
	
	# the unit height
	#my $unitH = $conf->{unit_height} || 20;
	my $unitH = _fetch_unitH($tree,$conf,$treeFH,$axis_flag);
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;

	my $id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
	
	my $tree_width = $treeFW - $id_width - $tail - $dataWidth;
	ERROR("tree_width_err") if ($tree_width <= 0);

	my $unitL = $tree_width / $treeL;
	my $svgH = ($#leaves) * $unitH + SBV::Font->fetch_font("leaf")->fetch_text_height;
	
	# draw branch length scale 
	if ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale} && $conf->{scale_no_offset})
	{
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		$group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");

		$group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit);
	}
	elsif ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale})
	#if ($rootNode->height && ! $conf->{ignore_branch_length})
	{
		# get font of scale
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		
		$svgH += $textH/2 + $unitH;
		$y += $textH/2;

		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		$group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");

		$group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit);
		$y += $unitH;
	}
	else
	{
		$y += $unitH if ($axis_flag);
	}
	
	$y += $unitH/2;
	$svgH += $unitH;

	$par{unitH} = $unitH;
	$par{unitL} = $unitL;
	$par{idX} = $x + $tail + $tree_width + 2*$hi;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
	$par{parent} = $group;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{treeY} = $y;

	# the main part
	# draw tree 
	my ($py,$ymin,$ymax) = _normal_tree($rootNode,$x + $tail,$y,\%par);
	
	# draw tail 
	my $id = "node_" . $rootNode->internal_id;
	$group->line(x1=>$x,x2=>$x+$tail,y1=>$py,y2=>$py,class=>"tail",id=>$id) if ($tail > 0);
	
	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
	
	# add the datasets 
	my %func = (
		marker     => \&_add_tree_marker,
		bar        => \&_add_tree_bar,
		simple_bar => \&_add_tree_simple_bar,
		multi_bar  => \&_add_tree_multi_bar,
		circles    => \&_add_tree_circles,
		boxplot    => \&_add_tree_boxplot,
		pie        => \&_add_tree_pie,
		connection => \&_add_tree_connection,
		heatmap    => \&_add_tree_heatmap,
		modify     => \&_add_tree_modify
	);
	
	my $dataX = $par{idX} + $par{idW} + 2*$hi;
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataX,%par) if ($dataset->{show} == 1);
		$dataX += $dataset->{width} + $hi * 2 if ($dataset->{type} ne "pie");
	}
}

sub _fetch_unitH
{
	my ($tree,$conf,$height,$axis_flag) = @_;
	
	my $unitH;
	my @leaves = $tree->get_leaf_nodes;
	my $label_font = SBV::Font->fetch_font("label");
	my $labelH = $label_font->fetch_text_height;

	if ($tree->get_root_node->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale} && !$conf->{scale_no_offset})
	#if ($tree->get_root_node->height && ! $conf->{ignore_branch_length})
	{
		# get font of scale
		my $scale_font = SBV::Font->fetch_font("scale");
		my $scaleH = $scale_font->fetch_text_height;

		$unitH = ($height - $scaleH/2) / ($#leaves + 2);
	}
	elsif ($axis_flag)
	{
		$unitH = $height/($#leaves + 2);	
	}
	else
	{
		$unitH = $height/($#leaves + 1);
	}

	return nearest 0.001 , $unitH;
}

sub _normal_tree
{
	my ($root,$ox,$oy,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $conf = $par->{conf};

	my ($left,$right) = $root->each_Descendent;
	my $leftL = nearest 0.01 , (_get_branch_length($left,$conf) * $unitL);
	my $rightL = nearest 0.01 , (_get_branch_length($right,$conf) * $unitL);

	my ($y1,$y2,$ymax,$ymin,$temp);
	if ($left->is_Leaf && $right->is_Leaf)
	{
		#($left,$right) = ($right,$left) if ($leftL < $rightL); # added at data 2014/08/13
		
		$y1 = $oy;
		$y2 = $oy + $unitH;
		$ymin = $y1 - $unitH/2;
		$ymax = $y2 + $unitH/2;
		
		_add_leaf($left,$ox,$y1,$par); # left leaf
		_add_leaf($right,$ox,$y2,$par); # right leaf
	}
	elsif ($left->is_Leaf)
	{
		$y1 = $oy;
		$ymin = $y1 - $unitH/2;
		($y2,$temp,$ymax) = _normal_tree($right,$ox+$rightL,$oy+$unitH,$par); # right tree
		_add_leaf($left,$ox,$y1,$par); #left leaf 
	}
	elsif ($right->is_Leaf)
	{
		$y1 = $oy;
		$ymin = $y1 - $unitH/2;
		
		#--------------------------------------------------------------------
		# left tree, but draw in the right , the leaf is default in left
		# this leaf order is very important
		#--------------------------------------------------------------------
		($y2,$temp,$ymax) = _normal_tree($left,$ox+$leftL,$oy+$unitH,$par);
		_add_leaf($right,$ox,$y1,$par);# right leaf
	}
	else
	{
		my @leftNodes = $left->get_all_Descendents;
		@leftNodes = grep { $_->is_Leaf } @leftNodes;

		my @rightNodes = $right->get_all_Descendents;
		@rightNodes = grep { $_->is_Leaf } @rightNodes;
		
		#($left,$right) = ($right,$left) if ($#leftNodes > $#rightNodes);
		
		if ($#leftNodes < $#rightNodes)
		{
			my $leftH = $#leftNodes * $unitH;
			($y1,$ymin,$temp) = _normal_tree($left,$ox+$leftL,$oy,$par);
			($y2,$temp,$ymax) = _normal_tree($right,$ox+$rightL,$oy+$leftH+$unitH,$par);
		}
		else 
		{
			my $rightH = $#rightNodes * $unitH;
			($y1,$ymin,$temp) = _normal_tree($right,$ox+$rightL,$oy,$par);
			($y2,$temp,$ymax) = _normal_tree($left,$ox+$leftL,$oy+$rightH+$unitH,$par);
		}
	}
	
	_add_clade($root,$ox,$y1,$y2,$ymin,$ymax,$par);
	return (($y1+$y2)/2,$ymin,$ymax);
}

# add the clade
sub _add_clade
{
	my ($root,$x,$y1,$y2,$ymin,$ymax,$par) = @_;

	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $idX = $par->{idX};
	my $hi = $SBV::conf->{hspace};
	
	# add the range 
	my $range = $parent->rect(x=>$x,y=>$ymin,width=>10,height=>$ymax-$ymin,class=>"range");

	my $y = ($y1+$y2)/2;
	my $clade_line1 = $parent->line(x1=>$x,x2=>$x,y1=>$y1,y2=>$y2,class=>"clade");
	
	my $root_len = $root eq $par->{rootNode} ? 0 : _get_branch_length($root,$par->{conf});

	my $clade_line2;
	my $x1 = $x;
	if ($root_len)
	{
		$x1 = nearest 0.01 , ($x-$root_len*$unitL);
		my $clade_line2_id = "node_" . $root->internal_id;
		$clade_line2 = $parent->line(x1=>$x1,x2=>$x,y1=>$y,y2=>$y,class=>"clade",id=>$clade_line2_id);
		_add_branch_length($root,$x1,$x,$y,$par);
		_add_bootstrap($root,$x,$y,$clade_line1,$clade_line2,$par);
	}

	# deal the definition
	if (my$def = $par->{defs}->{$root->internal_id})
	{
		if ($def->{clade})
		{
			$clade_line1->setAttribute("style","stroke:$def->{clade}->{color}");
			$clade_line2->setAttribute("style","stroke:$def->{clade}->{color}") if ($root_len);
		}
		
		if ($def->{range})
		{
			my ($width,$rectX);
			
			if (1 == $par->{conf}->{align})
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectX = $x1;
					$width = $idX - $x1 + $par->{idW} + $hi;
				}
				else
				{
					$rectX = $idX;
					$width = $par->{idW} + $hi;
				}
			}
			else
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectX = $x1;
					$width = $par->{idW} + $hi;
				}
				else
				{
					return;
				}
			}
			
			$range->setAttribute("x",$rectX);	
			$range->setAttribute("width",$width);
			$range->setAttribute("style","fill:$def->{range}->{color}");
			my $child1 = $parent->getFirstChild();
			$range = $parent->removeChild($range);
			$parent->insertBefore($range,$child1);
		}
	}
}

# add the leaf
# draw branch line and id
sub _add_leaf
{
	my($leaf,$x,$y,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $idX = $par->{idX};
	my $idW = $par->{idW};
	my $conf = $par->{conf};
	my $defs = $par->{defs};
	
	my $leafL = nearest 0.01 ,(_get_branch_length($leaf,$conf) * $unitL);
	my $x2 = $x + $leafL; 
	
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;
	
	# draw the range background for leaf and its branch
	my $range = $parent->rect(x=>$x,y=>$y-$unitH/2,width=>10,height=>$unitH,class=>"range");
	
	# draw leaf branch 
	my $leafLine_id = "node_" . $leaf->internal_id;
	my $leafLine = $parent->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"leaf",id=>$leafLine_id);
	
	# draw leaf branch length value
	_add_branch_length($leaf,$x,$x2,$y,$par);
	
	# draw leaf id
	my $textX;
	if (0 == $conf->{align})
	{
		$textX = $x2+$SBV::conf->{hspace};
	}
	else
	{
		$textX = $idX;
		$parent->line(x1=>$x2,x2=>$idX-$hi,y1=>$y,y2=>$y,
			class=>"linkage") if ($idX-$hi > $x2+$hi);
	}
	
	my $label = $leaf->id;
	my $leafText = $parent->text(x=>$textX,y=>$y+$textH/2,class=>"leaf")->cdata($label);
	
	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
		}

		if ($def->{label})
		{
			if ($def->{label}->{font})
			{
				#my $newText = SBV::DRAW::comboText($textX,$y+$textH/2,$def->{label}->{font},$parent,class=>"leaf");
				$label = $def->{label}->{font};
				$leafText->setAttribute("-cdata",$label);
			}
			
			if ($def->{label}->{style})
			{
				my $def_font = SBV::Font->new($def->{label}->{style});
			
				if ($def->{label}->{color})
				{
					$def_font->setAttr(fill=>$def->{label}->{color});
				}

				$leafText->setAttribute("style",$def_font->toStyle);
			}

		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};
			$range->setAttribute("x",$textX) if ($defconf->{cover} eq "label");

			my $width = 0;
			if ($defconf->{cover} eq "label")
			{
				$width = 1 == $conf->{align} ? $idW : $font->fetch_text_width($label);
			}
			else
			{
				$width = 1 == $conf->{align} ? ($idX-$x + $idW) : $x2-$x + $font->fetch_text_width($label);
			}
			
			$width = nearest 0.01 , $width +  $hi;
			$range->setAttribute("width",$width);
			$range->setAttribute("style","fill:$def->{range}->{color};stroke:$def->{range}->{color}");
		}
	}
	
}

# add bootstrap
sub _add_bootstrap
{
	my ($node,$x,$y,$line1,$line2,$par) = @_;
	
	my $parent = $par->{parent};
	my $conf = $par->{conf};
	return unless (defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	my $bootstrap = $node->bootstrap;
	return unless defined $bootstrap;
	
	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$parent->text(x=>$x-$textW-$hi,y=>$y+$textH+$vi,class=>"bootstrap")->cdata($bootstrap);
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$parent->text(x=>$x-$textW-$hi,y=>$y+$textH+$vi,class=>"bootstrap")->cdata($symbol);
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line1->setAttribute("style","stroke:$color");
		$line2->setAttribute("style","stroke:$color");
	}
}

# add branch length
sub _add_branch_length
{
	my ($node,$x1,$x2,$y,$par) = @_;
	
	return if (! $node->branch_length);
	
	my $conf = $par->{conf};
	
	return if (! $conf->{show_branch_length});
	
	my $unitL = $par->{unitL};
	my $parent = $par->{parent};
		
	my $font = SBV::Font->fetch_font('branch');
	my $textH = $font->fetch_text_height;
	
	my $bl = $node->branch_length;
	my $textW = $font->fetch_text_width($bl);
	my $textX = ($x1+$x2)/2 - $textW/2;
	$parent->text(x=>$textX,y=>$y-$SBV::conf->{vspace},class=>"branch")->cdata($bl);
}

# add the HGT arrow 
sub _add_HGT_arrow
{
	my ($file,$trans,$parent) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		my @arr = split /\t/;
		my $id1 = _trans_key($arr[0],"HGT",$trans);
		my $id2 = _trans_key($arr[1],"HGT",$trans);
		my $color = SBV::Colors::fetch_color($arr[2]);

		my $line1 = $SBV::svg->getElementByID("node_" . $id1);
		my $line2 = $SBV::svg->getElementByID("node_" . $id2);
		my $x1 = ($line1->getAttribute('x1') + $line1->getAttribute('x2')) / 2;
		my $x2 = ($line2->getAttribute('x1') + $line2->getAttribute('x2')) / 2;
		my $y1 = ($line1->getAttribute('y1') + $line1->getAttribute('y2')) / 2;
		my $y2 = ($line2->getAttribute('y1') + $line2->getAttribute('y2')) / 2;

		my $markid = SBV::DRAW::arrow(20,10,-zh=>0.5,-style=>"fill:$color",-class=>"arrow");
		$parent->line(x1=>$x1,x2=>$x2,y1=>$y1,y2=>$y2,
			style=>"stroke:$color",class=>"hgt",'marker-end'=>"url(#$markid)");
	}
	close FH;
}

#-------------------
# add datasets 
#------------------
# add tree marker
sub _add_tree_marker
{
	my ($dataset,$x,%par) = @_;
	
	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $class = $dataset->{border} ? "selector" : "marker";

	foreach my$id(keys %{$dataset->{data}})
	{
		my $fill = $dataset->{data}->{$id};
		my $style = "fill:$fill;";

		my $y = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		$parent->rect(x=>$x,y=>$y-$height/2,width=>$width,height=>$height,
			style=>$style,class=>$class);
	}
}

# add tree bar
sub _add_tree_bar
{
	my ($dataset,$x,%par) = @_;
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;

	# create x axis 
	my @sum = map { sum($_) } values %{$dataset->{data}};
	my $max = max(\@sum);
	my $scale = SBV::STAT::dividing(0,$max);
	my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,start=>0,translate=>0,tick=>$scale,side=>"left");
	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot;

	foreach my$id(keys %{$dataset->{data}})
	{
		my $rectx = $x;
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		my $i = 0;
		foreach my$num (@{$dataset->{data}->{$id}})
		{
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $color = loop_arr(\@color,$i);
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
				style=>"fill:$color",class=>"marker");
			$rectx += $rectw;
			$i ++;
		}
	}
}

sub _add_tree_simple_bar
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;
	
	# create x axis 
	my @nums = map { $_->[0] } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
	my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,tick=>$scale,start=>0,translate=>0,side=>"left");
	
	# hide the axis 
	unless ($par{show_axis})
	{
		$axis_par{'show_tick_line'} = 0;
		$axis_par{'show_tick_label'} = 0;
	}

	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);
		my $rectx = $x;
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		my $num = $dataset->{data}->{$id}->[0];
		my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
		$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
			style=>"fill:$color",class=>"marker");
		$i ++;
	}
}

sub _add_tree_multi_bar
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;
	
	my @values = values %{$dataset->{data}};
	my $bar_num = scalar @{$values[0]};
	my $bar_width = nearest 0.01 , ($width / $bar_num);
	
	for my$index (0 .. $bar_num-1)
	{
		my $color = loop_arr(\@color,$index);
		my @nums = map { $_->[$index] } values %{$dataset->{data}};
		my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
		my %axis_par = (parent=>$parent,ox=>$x+$bar_width*$index,oy=>$oy,length=>$bar_width,start=>0,translate=>0,tick=>$scale,side=>"left");
		
		# hide the axis 
		unless ($par{show_axis})
		{
			$axis_par{'show_tick_line'} = 0;
			$axis_par{'show_tick_label'} = 0;
		}

		my $axis = SBV::STONE::AXIS->new(%axis_par);
		$axis->plot;

		foreach my$id(keys %{$dataset->{data}})
		{
			my $rectx = $x + $index*$bar_width;
			my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
			my $num = $dataset->{data}->{$id}->[$index];
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
					style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_tree_circles
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $circle_num = scalar @{$values[0]};
	my $space = ($width - $circle_num * $height) / ($circle_num - 1);
	my @nums = map { $_->[0] } @values;
	my $max = max(\@nums);
	
	for my$index (0 .. $circle_num-1)
	{
		my $color = loop_arr(\@color,$index);
		foreach my$id(keys %{$dataset->{data}})
		{
			my $cx = nearest 0.01 , ($x + $index * ($space + $height) + $height/2);
			my $cy = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
			my $r = nearest 0.01 , ($height/2 * $dataset->{data}->{$id}->[$index] / $max); 
			$parent->circle(cx=>$cx,cy=>$cy,r=>$r,style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_tree_boxplot
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;

	# create x axis 
	my @nums;
	map { splice(@nums,0,0,@$_) } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums);
	my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,start=>0,translate=>0,tick=>$scale,side=>"left");
	
	# hide the axis 
	unless ($par{show_axis})
	{
		$axis_par{'show_tick_line'} = 0;
		$axis_par{'show_tick_label'} = 0;
	}

	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);

		my @val = @{ $dataset->{data}->{$id} };
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;
		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;
		
		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}

		my $y2 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		my $y1 = $y2 - $height/2;
		my $y3 = $y2 + $height/2;
		
		my $q3x = $x + $axis->fetch_dis($q3);
		my $q2x = $x + $axis->fetch_dis($q2);
		my $q1x = $x + $axis->fetch_dis($q1);
		my $upx = $x + $axis->fetch_dis($upval);
		my $lowx = $x + $axis->fetch_dis($lowval);
		my $w = ($q3x-$q1x);

		$parent->rect(y=>$y1,x=>$q1x,height=>$height,width=>$w,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(y1=>$y1,x1=>$q2x,y2=>$y3,x2=>$q2x,
			style=>{stroke=>$color,'stroke-width'=>2});
		$parent->line(y1=>$y2,y2=>$y2,x1=>$q3x,x2=>$upx,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(y1=>$y2,y2=>$y2,x1=>$q1x,x2=>$lowx,
			style=>{stroke=>$color,'stroke-width'=>1});
		foreach my$i (@abnormal)
		{
			my $ix = $x + $axis->fetch_dis($i);
			$parent->circle(cy=>$y2,cx=>$ix,r=>2,style=>{fill=>$color,'stroke-width'=>0});
		}

		$i ++;
	}	
}

sub _add_tree_pie
{
	my ($dataset,$x,%par) = @_;	

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };

	my $R = $par{unitH} * $dataset->{height};
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $x1 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('x1');
		my $x2 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('x2');
		my $cx = ($x1+$x2)/2;
		my $cy = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		
		my @vals = @{$dataset->{data}->{$id}};
		my $sum = sum(\@vals);
		my $temp = 0;
		my $group = $parent->group();
		foreach my$i(0 .. $#vals)
		{
			my $color = loop_arr(\@color,$i);
			my %fan = (start=>$temp,color=>$color,r1=>0,class=>'pie',parent=>$group);
			SBV::DRAW::Fan($cx,$cy,$sum,$temp+$vals[$i],$R/2,%fan);
			$temp += $vals[$i];
		}
	}
}

sub _add_tree_heatmap
{
	my ($dataset,$x,%par) = @_;	
	
	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @colors = @{ $dataset->{color} };

	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = max(\@nums);
	my $min = min(\@nums);
	my $block_width = $width/$col_num;

	my $scale = $dataset->{scale} || "none";
	
	# fetch the column min and max ( for scale == column )
	my (@cmin,@cmax);
	if ($scale eq "column")
	{
		foreach my$i (0 .. $col_num-1)
		{
			my @temp = map { $_->[$i] } @values;
			push @cmin , min(\@temp);
			push @cmax , max(\@temp);
		}
	}
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		
		if ($scale eq "row")
		{
			$min = min(\@vals);
			$max = max(\@vals);
		}
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		foreach my$index(0 .. $#vals)
		{
			if ($scale eq "column")
			{
				$min = $cmin[$index];
				$max = $cmax[$index];
			}
			my $rectx = $x + $index * $block_width;
			
			my ($ratio,$color);
			
			if ($min != $max)
			{
				$ratio = ($vals[$index]-$min)/($max-$min);
				$color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			}
			else 
			{
				$color = "none";
			}

			$parent->rect(x=>$rectx,y=>$recty,width=>$block_width,height=>$height,
				style=>"fill:$color",class=>"heatmap");
		}
	}
}

sub _add_tree_connection
{
		
}

sub _add_tree_modify
{
	my ($dataset,$x,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	
	my $maxLen;
	if ($dataset->{format} eq "domain")
	{
		my @length = map {$_->[0]->[0]} values %{$dataset->{data}};
		$maxLen = max(\@length);
	}

	foreach my$id(keys %{$dataset->{data}})
	{
		my $y = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		
		if ($dataset->{format} eq "domain")
		{
			my $len = $dataset->{data}->{$id}->[0]->[0];
			$parent->line(x1=>$x,x2=>$x+$len*$width/$maxLen,y1=>$y,y2=>$y) if $dataset->{bgline};

			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($len,$sta,$end,$shape,$color,$fill,$label) = @$modify;
				my $usex = $x + $sta/$maxLen * $width;
				my $usew = ($end-$sta+1)/$maxLen * $width;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group()->use(x=>$usex,y=>$y-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
			}
		}
		elsif ($dataset->{format} eq "symbol")
		{
			my $i = 0;
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($shape,$color,$fill,$label) = @$modify;
				my $usex = $x + ($height+$hi) * $i;
				my $usew = $height;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group()->use(x=>$usex,y=>$y-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
				$i ++;
			}
		}
	}
}

#----------draw normal tree function done----------------------
#--------------------------------------------------------------

#-------------------------------------------------------------------------------
#  draw circular tree
#-------------------------------------------------------------------------------
sub circular_tree
{
	my ($self,$tree,$conf,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	
	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;

	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}
	
	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	# the root tail length
	my $tail = $conf->{tail} || 10;
	ERROR("negative_length_err",$tail) if ($tail < 0);

	my $x = $conf->{ox};
	my $y = $conf->{oty};

	my $unit = $conf->{unit} || 0.01;
	my $treeL = tree_length($rootNode,$conf);
	my @leaves = $tree->get_leaf_nodes;
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;
	
	# the unit Angle
	my $unitA = $conf->{angle} / ($#leaves + 1);
	
	# set the radius and circle origin points coord
	my $or = $conf->{radius};
	my $R = $conf->{tw} > $conf->{th} ? $conf->{th} : $conf->{tw};
	my $r = $R/2;
	my $cx = $x + $conf->{tw}/2;
	my $cy = $y + $conf->{th}/2;
	
	# rotate the group
	if (my $rotation = $conf->{rotation})
	{
		$rotation = $rotation * 360 / $TWOPI;
		$group->setAttribute("transform","rotate($rotation,$cx,$cy)");
	}
	
	# set the unit length 
	my $id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
	my $tree_width = $r - $or - $id_width - $tail - 2*$hi - $dataWidth;
	my $unitL = $tree_width / $treeL;

	# creat new plolar coord system for circular tree
	my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$group);

	# set the par
	$par{unitH} = $conf->{unit_height};
	$par{unitA} = $unitA;
	$par{unitL} = $unitL;
	$par{idR} = $or + $tail + $tree_width + $hi;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
	$par{parent} = $group;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{cx} = $cx;
	$par{cy} = $cy;
	$par{r} = $r;
	$par{polar} = $polar;
	
	# draw branch length scale 
	my $font = SBV::Font->fetch_font("scale");
	my $textH = $font->fetch_text_height;
	my $unit_len = $unit * $unitL;
	$polar->line($par{idR}-$hi,-$unitA,$par{idR}-$hi-$unit_len,-$unitA,class=>"scale");
	$polar->text($par{idR},-$unitA,$textH/2,$unit,class=>"scale");

	# the main part
	# draw tree 
	my ($pa,$amin,$amax) = _circular_tree($rootNode,$or+$tail,0,\%par);
	
	# draw tail 
	my $id = "node_" . $rootNode->internal_id;
	$polar->line($or,$pa,$or+$tail,$pa,class=>"tail",id=>$id) if ($tail > 0);

	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
	
	# add the datasets 
	my %func = (
		marker     => \&_add_circular_tree_marker,
		bar        => \&_add_circular_tree_bar,
		simple_bar => \&_add_circular_tree_simple_bar,
		multi_bar  => \&_add_circular_tree_multi_bar,
		circles    => \&_add_circular_tree_circles,
		boxplot    => \&_add_circular_tree_boxplot,
		pie        => \&_add_circular_tree_pie,
		connection => \&_add_circular_tree_connection,
		heatmap    => \&_add_circular_tree_heatmap,
		modify     => \&_add_circular_tree_modify
	);
	my $dataR = $par{idR} + $par{idW} + 4*$hi;
	
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataR,%par);
		$dataR += $dataset->{width} + $hi * 2 if ($dataset->{type} ne "pie");
	}
}

sub _circular_tree
{
	my ($root,$r,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $polar = $par->{polar};
	my $parent = $par->{parent};
	my $conf = $par->{conf};

	my ($left,$right) = $root->each_Descendent;
	my $leftL = nearest 0.01 , (_get_branch_length($left,$conf) * $unitL);
	my $rightL = nearest 0.01 , (_get_branch_length($right,$conf) * $unitL);
	
	my ($a1,$a2,$amax,$amin,$temp);
	if ($left->is_Leaf && $right->is_Leaf)
	{
		$a1 = $a;
		$a2 = $a + $unitA;
		$amin = $a1 - $unitA/2;
		$amax = $a2 + $unitA/2;
		_add_circular_leaf($left,$r,$a1,$par); # left leaf
		_add_circular_leaf($right,$r,$a2,$par); # right leaf
	}
	elsif ($left->is_Leaf)
	{
		$a1 = $a;
		$amin = $a1 - $unitA/2;
		($a2,$temp,$amax) = _circular_tree($right,$r+$rightL,$a+$unitA,$par); # right tree
		_add_circular_leaf($left,$r,$a1,$par); #left leaf 
	}
	elsif ($right->is_Leaf)
	{
		$a1 = $a;
		$amin = $a1 - $unitA/2;
		# left tree, but draw in the right , the leaf is default in left
		($a2,$temp,$amax) = _circular_tree($left,$r+$leftL,$a+$unitA,$par);
		_add_circular_leaf($right,$r,$a1,$par);# right leaf
	}
	else
	{
		my @leftNodes = $left->get_all_Descendents;
		@leftNodes = grep { $_->is_Leaf } @leftNodes;

		my @rightNodes = $right->get_all_Descendents;
		@rightNodes = grep { $_->is_Leaf } @rightNodes;

		if ($#leftNodes < $#rightNodes)
		{
			my $leftA = $#leftNodes * $unitA;
			($a1,$amin,$temp) = _circular_tree($left,$r+$leftL,$a,$par);
			($a2,$temp,$amax) = _circular_tree($right,$r+$rightL,$a+$leftA+$unitA,$par);
		}
		else
		{
			my $rightA = $#rightNodes * $unitA;
			($a1,$amin,$temp) = _circular_tree($right,$r+$rightL,$a,$par);
			($a2,$temp,$amax) = _circular_tree($left,$r+$leftL,$a+$rightA+$unitA,$par);
		}
	}
	
	_add_circular_clade($root,$r,$a1,$a2,$amin,$amax,$par);
	return (($a1+$a2)/2,$amin,$amax);
}

# add the circular clade
sub _add_circular_clade
{
	my ($root,$r,$a1,$a2,$amin,$amax,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $polar = $par->{polar};
	my $parent = $par->{parent};
	my $idR = $par->{idR};
	my $hi = $SBV::conf->{hspace};
	
	# set the range par and coord
	my @range_coord = ($r,$amin,$r+10,$amax);
	my %range_par = (class=>"range");

	# draw the clade arc
	my $a = ($a1+$a2)/2;
	my $clade_line1 = $polar->pline($r,$a1,$a2,class=>"clade");
	$par->{angle}->{$root->internal_id} = $a;

	# draw the clade line
	my $clade_line2;
	my $r1 = $r;
	my $root_len = $root eq $par->{rootNode} ? 0 : _get_branch_length($root,$par->{conf});
	if ($root_len)
	{
		$r1 = nearest 0.01 , ($r-$root_len*$unitL);
		my $clade_line2_id = "node_" . $root->internal_id;
		$clade_line2 = $polar->line($r1,$a,$r,$a,class=>"clade",id=>$clade_line2_id);
		_add_circular_branch_length($root,$r1,$r,$a,$par);
		_add_circular_bootstrap($root,$r,$a,$clade_line1,$clade_line2,$par);
	}

	# deal the definition
	if (my$def = $par->{defs}->{$root->internal_id})
	{
		if ($def->{clade})
		{
			$clade_line1->setAttribute("style","stroke:$def->{clade}->{color}");
			$clade_line2->setAttribute("style","stroke:$def->{clade}->{color}") if ($root_len);
		}
		
		if ($def->{range})
		{
			my ($width,$rectR);
			
			if (1 == $par->{conf}->{align})
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $idR - $r1 + $par->{idW} + $hi;
				}
				else
				{
					$rectR = $idR;
					$width = $par->{idW} + $hi;
				}
			}
			else
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $par->{idW} + $hi;
				}
				else
				{
					return;
				}
			}
			
			$range_coord[0] = $rectR;
			$range_coord[2] = $range_coord[0] + $width;
			$range_par{"style"} = "fill:$def->{range}->{color}";
			my $child1 = $parent->getFirstChild();
			my $range = $polar->prect(@range_coord,%range_par);
			$range = $parent->removeChild($range);
			$parent->insertBefore($range,$child1);
		}
	}
}

# add the circular leaf
# draw branch line and id
sub _add_circular_leaf
{
	my($leaf,$r,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $idR = $par->{idR};
	my $idW = $par->{idW};
	my $conf = $par->{conf};
	my $defs = $par->{defs};
	
	my $leafL = nearest 0.01 ,(_get_branch_length($leaf,$conf) * $unitL);
	my $r2 = $r + $leafL; 
	
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;
	
	# draw the range background for leaf and its branch
	my @range_coord = ($r,$a-$unitA/2,$r+10,$a+$unitA/2);
	my %range_par = (class=>"range");
	my $range = $polar->prect(@range_coord,%range_par);
	
	# draw leaf branch 
	my $leafLine_id = "node_" . $leaf->internal_id;
	my $leafLine = $polar->line($r,$a,$r2,$a,class=>"leaf",id=>$leafLine_id);
	$par->{angle}->{$leaf->internal_id} = $a;
	
	# draw leaf branch length value
	_add_circular_branch_length($leaf,$r,$r2,$a,$par);
	
	# draw leaf id
	my $textR;
	if (0 == $conf->{align})
	{
		$textR = $r2+$SBV::conf->{hspace};
	}
	else
	{
		$textR = $idR;
		$polar->line($r2,$a,$idR-$hi,$a,class=>"linkage") if ($idR-$hi > $r2+$hi);
	}
	
	my $label = $leaf->id;
	my $leafText = $polar->text($textR,$a,$textH/2,$label,class=>"leaf");
	
	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
		}

		if ($def->{label})
		{
			if ($def->{label}->{font})
			{
				#my $newText = SBV::DRAW::comboText($textX,$y+$textH/2,$def->{label}->{font},$parent,class=>"leaf");
				$label = $def->{label}->{font};
				$leafText->setAttribute("-cdata",$label);
			}

			if ($def->{label}->{color})
			{
				$leafText->setAttribute("style","fill:$def->{label}->{color}");
			}
		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};

			my $width = 0;
			if ($defconf->{cover} eq "label")
			{
				$range_coord[0] = $idR;
				$width = 1 == $conf->{align} ? $idW : $font->fetch_text_width($label);
			}
			else
			{
				$width = 1 == $conf->{align} ? ($idR-$r + $idW) : $r2-$r + $font->fetch_text_width($label);
			}
			
			$width = nearest 0.01 , $width +  $hi;
			$range_coord[2] = $range_coord[0] + $width;
			$range_par{style} = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
		}
	}
	
	if ($range_coord[0] == $range_coord[2]+10)
	{
		$parent->removeChild($range);
	}
	else
	{
		my $range1 = $polar->prect(@range_coord,%range_par);
		$parent->replaceChild($range1,$range);
	}
}

# add bootstrap in circular tree
sub _add_circular_bootstrap
{
	my ($node,$r,$a,$line1,$line2,$par) = @_;
	
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $conf = $par->{conf};
	return if (! defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	my $bootstrap = $node->bootstrap;
	return unless defined $bootstrap;
	
	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$bootstrap,class=>"bootstrap");
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$symbol,class=>"bootstrap");
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line1->setAttribute("style","stroke:$color");
		$line2->setAttribute("style","stroke:$color");
	}
}

# add branch length in circular tree
sub _add_circular_branch_length
{
	my ($node,$r1,$r2,$a,$par) = @_;
	
	return if (! $node->branch_length);
	
	my $conf = $par->{conf};
	
	return if (! $conf->{show_branch_length});
	
	my $unitL = $par->{unitL};
	my $parent = $par->{parent};
	my $polar = $par->{polar};
		
	my $font = SBV::Font->fetch_font('branch');
	my $textH = $font->fetch_text_height;
	
	my $bl = $node->branch_length;
	my $textW = $font->fetch_text_width($bl);
	my $textR = ($r1+$r2)/2 - $textW/2;
	$polar->text($textR,$a,-$SBV::conf->{vspace},$bl,class=>"branch");
}

# add the HGT arrow in circular tree
sub _add_circular_HGT_arrow
{
	my ($file,$trans,$parent) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		my @arr = split /\t/;
		my $id1 = _trans_key($arr[0],"HGT",$trans);
		my $id2 = _trans_key($arr[1],"HGT",$trans);
		my $color = SBV::Colors::fetch_color($arr[2]);

		my $line1 = $SBV::svg->getElementByID("node_" . $id1);
		my $line2 = $SBV::svg->getElementByID("node_" . $id2);
		my $x1 = ($line1->getAttribute('x1') + $line1->getAttribute('x2')) / 2;
		my $x2 = ($line2->getAttribute('x1') + $line2->getAttribute('x2')) / 2;
		my $y1 = ($line1->getAttribute('y1') + $line1->getAttribute('y2')) / 2;
		my $y2 = ($line2->getAttribute('y1') + $line2->getAttribute('y2')) / 2;

		my $markid = SBV::DRAW::arrow(20,10,-zh=>0.5,-style=>"fill:$color",-class=>"arrow");
		$parent->line(x1=>$x1,x2=>$x2,y1=>$y1,y2=>$y2,
			style=>"stroke:$color",class=>"hgt",'marker-end'=>"url(#$markid)");
	}
	close FH;
}

#-------------------------------------------------------------------------------
# add dataset in circular tree
#-------------------------------------------------------------------------------
# tree marker
sub _add_circular_tree_marker
{
	my ($dataset,$r,%par) = @_;
	
	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $polar = $par{polar};
	my $class = $dataset->{border} ? "selector" : "marker";

	foreach my$id(keys %{$dataset->{data}})
	{
		my $fill = $dataset->{data}->{$id};
		my $style = "fill:$fill;";

		my $a = $par{angle}->{$id};
		$polar->prect($r,$a-$angle/2,$r+$width,$a+$angle/2,style=>$style,class=>$class);
	}
}

# add tree bar
sub _add_circular_tree_bar
{
	my ($dataset,$r,%par) = @_;
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };

	# create x axis 
	my $unitA = $par{unitA} * 360 / $TWOPI;
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @sum = map { sum($_) } values %{$dataset->{data}};
	my $max = max(\@sum);
	my $scale = SBV::STAT::dividing(0,$max);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy - $r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
	
	# hide the axis 
	unless ($par{show_axis})
	{
		$axis_par{'show_tick_line'} = 0;
		$axis_par{'show_tick_label'} = 0;
	}

	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot();

	foreach my$id(keys %{$dataset->{data}})
	{
		my $rectx = $cx + $r;
		my $recty = $cy - $height/2;
		my $i = 0;
		my $a = $par{angle}->{$id};
		$a = $a * 360 / $TWOPI - 90;
		foreach my$num (@{$dataset->{data}->{$id}})
		{
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $color = loop_arr(\@color,$i);
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
				style=>"fill:$color",class=>"marker",transform=>"rotate($a,$cx,$cy)");
			$rectx += $rectw;
			$i ++;
		}
	}
}

sub _add_circular_tree_simple_bar
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $polar = $par{polar};
	
	# create x axis 
	my $unitA = $par{unitA} * 360 / $TWOPI;
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @nums = map { $_->[0] } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy - $r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
	
	# hide the axis 
	unless ($par{show_axis})
	{
		$axis_par{'show_tick_line'} = 0;
		$axis_par{'show_tick_label'} = 0;
	}

	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);
		my $rectx = $cx + $r;
		my $recty = $cy - $height/2;
		my $num = $dataset->{data}->{$id}->[0];
		my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
		my $rotate = $par{angle}->{$id} * 360 / $TWOPI - 90;
		$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
			style=>"fill:$color",class=>"marker",transform=>"rotate($rotate,$cx,$cy)");
		$i ++;
	}
}

sub _add_circular_tree_multi_bar
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my $unitA = $par{unitA} * 360 / $TWOPI;
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my @values = values %{$dataset->{data}};
	my $bar_num = scalar @{$values[0]};
	my $bar_width = nearest 0.01 , ($width / $bar_num);
	
	for my$index (0 .. $bar_num-1)
	{
		my $color = loop_arr(\@color,$index);
		my @nums = map { $_->[$index] } values %{$dataset->{data}};
		my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
		my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy-$r-$index*$bar_width
			,length=>$bar_width,tick=>$scale,side=>"left",start=>0,translate=>0,angle=>-90);
	
		# hide the axis 
		unless ($par{show_axis})
		{
			$axis_par{'show_tick_line'} = 0;
			$axis_par{'show_tick_label'} = 0;
		}


		my $axis = SBV::STONE::AXIS->new(%axis_par);
		$axis->plot;

		foreach my$id(keys %{$dataset->{data}})
		{
			my $rectx = $cx + $r + $index*$bar_width;
			my $recty = $cy - $height/2;
			my $num = $dataset->{data}->{$id}->[$index];
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $rotate = $par{angle}->{$id} * 360 / $TWOPI - 90;
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
					style=>"fill:$color",class=>"marker",transform=>"rotate($rotate,$cx,$cy)");
		}
	}
}

sub _add_circular_tree_circles
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $circle_num = scalar @{$values[0]};
	my $space = ($width - $circle_num * $height) / ($circle_num - 1);
	my @nums = map { $_->[0] } @values;
	my $max = max(\@nums);
	my $pcx = $polar->{cx};
	my $pcy = $polar->{cy};
	
	for my$index (0 .. $circle_num-1)
	{
		my $color = loop_arr(\@color,$index);
		foreach my$id(keys %{$dataset->{data}})
		{
			my $rotate = $par{angle}->{$id} * 360 / $TWOPI - 90;
			my $cx = nearest 0.01 , ($pcx + $r + $index * ($space + $height) + $height/2);
			my $cy = $pcy;
			my $r = nearest 0.01 , ($height/2 * $dataset->{data}->{$id}->[$index] / $max); 
			$parent->circle(cx=>$cx,cy=>$cy,r=>$r,style=>"fill:$color",
				class=>"marker",transform=>"rotate($rotate,$pcx,$pcy)");
		}
	}
}

sub _add_circular_tree_boxplot
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{$dataset->{color}};

	# create x axis 
	my $unitA = $par{unitA} * 360 / $TWOPI;
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @nums;
	map { splice(@nums,0,0,@$_) } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy-$r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
	
	# hide the axis 
	unless ($par{show_axis})
	{
		$axis_par{'show_tick_line'} = 0;
		$axis_par{'show_tick_label'} = 0;
	}

	my $axis = SBV::STONE::AXIS->new(%axis_par);
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $rotate = $par{angle}->{$id} * 360 / $TWOPI - 90;
		my $boxplot_parent = $parent->group(transform=>"rotate($rotate,$cx,$cy)");
		my $color = loop_arr(\@color,$i);
		my @val = @{ $dataset->{data}->{$id} };
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;
		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;
		
		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}

		my $y2 = $cy;
		my $y1 = $y2 - $height/2;
		my $y3 = $y2 + $height/2;
		
		my $q3x = $cx + $r + $axis->fetch_dis($q3);
		my $q2x = $cx + $r + $axis->fetch_dis($q2);
		my $q1x = $cx + $r + $axis->fetch_dis($q1);
		my $upx = $cx + $r + $axis->fetch_dis($upval);
		my $lowx = $cx + $r + $axis->fetch_dis($lowval);
		my $w = ($q3x-$q1x);

		$boxplot_parent->rect(y=>$y1,x=>$q1x,height=>$height,width=>$w,
			style=>{stroke=>$color,'stroke-width'=>1});
		$boxplot_parent->line(y1=>$y1,x1=>$q2x,y2=>$y3,x2=>$q2x,
			style=>{stroke=>$color,'stroke-width'=>2});
		$boxplot_parent->line(y1=>$y2,y2=>$y2,x1=>$q3x,x2=>$upx,
			style=>{stroke=>$color,'stroke-width'=>1});
		$boxplot_parent->line(y1=>$y2,y2=>$y2,x1=>$q1x,x2=>$lowx,
			style=>{stroke=>$color,'stroke-width'=>1});
		foreach my$i (@abnormal)
		{
			my $ix = $cx + $r + $axis->fetch_dis($i);;
			$boxplot_parent->circle(cy=>$y2,cx=>$ix,r=>2,style=>{fill=>$color,'stroke-width'=>0});
		}

		$i ++;
	}	
}

sub _add_circular_tree_pie
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	my $R = $par{unitH} || 20;
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $line = $SBV::svg->getElementByID("node_$id");
		my $cx = ( $line->getAttribute('x1') + $line->getAttribute('x2') )/ 2;
		my $cy = ( $line->getAttribute('y1') + $line->getAttribute('y2') )/ 2;

		my @vals = @{$dataset->{data}->{$id}};
		my $sum = sum(\@vals);
		my $temp = 0;
		my $group = $parent->group();
		foreach my$i(0 .. $#vals)
		{
			my $color = loop_arr(\@color,$i);
			my %fan = (start=>$temp,color=>$color,r1=>0,class=>'pie',parent=>$group);
			SBV::DRAW::Fan($cx,$cy,$sum,$temp+$vals[$i],$R/2,%fan);
			$temp += $vals[$i];
		}
	}
}

sub _add_circular_tree_heatmap
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @colors = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = max(\@nums);
	my $min = min(\@nums);
	my $block_width = $width/$col_num;

	my $scale = $dataset->{scale} || "none";
	
	# fetch the column min and max ( for scale == column )
	my (@cmin,@cmax);
	if ($scale eq "column")
	{
		foreach my$i (0 .. $col_num-1)
		{
			my @temp = map { $_->[$i] } @values;
			push @cmin , min(\@temp);
			push @cmax , max(\@temp);
		}
	}
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		
		if ($scale eq "row")
		{
			$min = min(\@vals);
			$max = max(\@vals);
		}
		my $a = $par{angle}->{$id};
		foreach my$index(0 .. $#vals)
		{
			if ($scale eq "column")
			{
				$min = $cmin[$index];
				$max = $cmax[$index];
			}

			my ($ratio,$color);

			if ($max != $min)
			{
				$ratio = ($vals[$index]-$min)/($max-$min);
				$color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			}
			else 
			{
				$color = "none";
			}
			
			my $rectr = $r + $index * $block_width;
			$polar->prect($rectr,$a-$angle/2,$rectr+$block_width,$a+$angle/2,style=>"fill:$color",class=>"heatmap");
		}
	}
}

sub _add_circular_tree_connection
{
	my ($dataset,$r,%par) = @_;	
		
}

sub _add_circular_tree_modify
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my $height = $dataset->{height} * $par{unitH};
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $a = $par{angle}->{$id};

		if ($dataset->{format} eq "domain")
		{
			$polar->line($r,$a,$r+$width,$a);
			$a = $a * 360 / $TWOPI - 90;
			my @length = map {$_->[0]->[0]} values %{$dataset->{data}};
			my $maxLen = max(\@length);

			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($len,$sta,$end,$shape,$color,$fill,$label) = @$modify;
				my $usex = $polar->{cx} + $r + $sta/$maxLen * $width;
				my $usew = ($end-$sta+1)/$len * $width;
				my $symid = SBV::STONE::SYMBOL::new($shape,
					height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group(transform=>"rotate($a $cx $cy)")->use(
					x=>$usex,y=>$polar->{cy}-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
			}
		}
		elsif ($dataset->{format} eq "symbol")
		{
			my $i = 0;
			$a = $a * 360 / $TWOPI - 90;
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($shape,$color,$fill,$label) = @$modify;
				my $usex =$polar->{cx} + $r + ($height+$hi) * $i;
				my $usew = $height;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group(transform=>"rotate($a $cx $cy)")->use(
					x=>$usex,y=>$polar->{cy}-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
				$i ++;
			}
		}
	}
}

# draw circular tree done
#------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#  Inverted circular tree 
#-------------------------------------------------------------------------------


#  draw Inverted circular tree done
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#   unrooted tree
#-------------------------------------------------------------------------------
sub unrooted_tree
{
	my ($self,$tree,$conf,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	
	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}
	
	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	my $x = $conf->{ox};
	my $y = $conf->{oty};

	my $unit = $conf->{unit} || 0.01;
	my $treeL = tree_length($rootNode,$conf);
	my @leaves = $tree->get_leaf_nodes;
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;
	
	# the unit Angle
	my $unitA = $conf->{angle} / ($#leaves + 1);
	
	# set the radius and circle origin points coord
	my $R = $conf->{tw} > $conf->{th} ? $conf->{th} : $conf->{tw};
	my $r = $R/2;
	my $cx = $x + $conf->{tw}/2;
	my $cy = $y + $conf->{th}/2;
	
	# rotate the group
	if (my $rotation = $conf->{rotation})
	{
		$rotation = $rotation * 360 / $TWOPI;
		$group->setAttribute("transform","rotate($rotation,$cx,$cy)");
	}
	
	# set the unit length 
	my $id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
	my $tree_width = $r - $id_width - 2*$hi - $dataWidth;
	my $unitL = $tree_width / $treeL;
	my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$group);

	# set the par
	$par{unitH} = $conf->{unit_height};
	$par{unitA} = $unitA;
	$par{unitL} = $unitL;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
	$par{parent} = $group;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{r} = $r;
	$par{polar} = $polar;

	# draw branch length scale 
	if ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale})
	{
		# get font of scale
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		my $y = $y + $textH/2;
		$group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");
		$group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit);
	}

	# the main part
	# draw tree 
	_add_unrooted_tree_clade($rootNode,$polar,0,\%par);

	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
	
	# now not support datasets for unrooted tree
	return;

	# add the datasets 
	my %func = (
		marker     => \&_add_unrooted_tree_marker,
		bar        => \&_add_unrooted_tree_bar,
		simple_bar => \&_add_unrooted_tree_simple_bar,
		multi_bar  => \&_add_unrooted_tree_multi_bar,
		circles    => \&_add_unrooted_tree_circles,
		boxplot    => \&_add_unrooted_tree_boxplot,
		pie        => \&_add_unrooted_tree_pie,
		connection => \&_add_unrooted_tree_connection,
		heatmap    => \&_add_unrooted_tree_heatmap,
		modify     => \&_add_unrooted_tree_modify
	);
	my $dataR = $par{idR} + $par{idW} + 4*$hi;
	
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataR,%par);
		$dataR += $dataset->{width} + $hi * 2 if ($dataset->{type} ne "pie");
	}
}

sub _add_unrooted_tree_clade
{
	my ($root,$polar,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $parent = $par->{parent};
	my $conf = $par->{conf};
	
	my $rootL = nearest 0.01 , (_get_branch_length($root,$conf) * $unitL);
	my @nodes = $root->get_all_Descendents;
	my @leaves = grep { $_->is_Leaf } @nodes;
	my $sumA = $unitA * ($#leaves);
	
	my ($left,$right) = $root->each_Descendent;
	if ($root != $par->{rootNode})
	{
		my $range = $parent->group(class=>"range");
		my $line = $polar->line(0,0,$rootL,$a+$sumA/2,class=>"clade",id=>"node_" . $root->internal_id);
		
		# branch length
		_add_unrooted_branch_length($root,0,$rootL,$a,$par);
		# bootstrap
		_add_unrooted_bootstrap($root,$rootL,$a+$sumA/2,$line,$par);
		
		# deal the definition
		if (my$def = $par->{defs}->{$root->internal_id})
		{
			$line->setAttribute("style","stroke:$def->{clade}->{color}") if ($def->{clade});
			if ($def->{range})
			{
				my $defconf = $conf->{'definition'};
				my $style = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
				my $theta1 = $a + $sumA/2 - $unitA/2;
				my $theta2 = $a + $sumA/2 + $unitA/2;
				$polar->parent($range);
				$polar->fan(0,$theta1,$rootL,$theta2,class=>"range",style=>$style);
				$polar->parent($parent);
			}
		}
		
		# create new polar coord
		my ($cx,$cy) = $polar->polar2pos($rootL,$a+$sumA/2);
		$polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$parent);
		$par->{polar} = $polar;
	}
	
	if ($left->is_Leaf && $right->is_Leaf)
	{
		_add_unrooted_tree_leaf($left,$polar,$a,$par);
		_add_unrooted_tree_leaf($right,$polar,$a+$unitA,$par);
	}
	elsif ($left->is_Leaf)
	{
		_add_unrooted_tree_leaf($left,$polar,$a,$par);
		_add_unrooted_tree_clade($right,$polar,$a+$unitA,$par);
	}
	elsif ($right->is_Leaf)
	{
		_add_unrooted_tree_leaf($right,$polar,$a,$par);
		_add_unrooted_tree_clade($left,$polar,$a+$unitA,$par);
	}
	else
	{
		my $leftA = _add_unrooted_tree_clade($left,$polar,$a,$par);	
		_add_unrooted_tree_clade($right,$polar,$a+$leftA+$unitA,$par);
	}
	
	return $sumA;
}

sub _add_unrooted_tree_leaf
{
	my ($leaf,$polar,$a,$par) = @_;
	my $conf = $par->{conf};
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;
	my $defs = $par->{defs};
	my $parent = $par->{parent};

	# draw the range background for leaf and its branch
	my $range = $par->{parent}->group(class=>"range");
	
	my $leafL = nearest 0.01 , (_get_branch_length($leaf,$conf) * $unitL);
	my $leafLine = $polar->line(0,0,$leafL,$a,class=>"leaf",id=>"node_" . $leaf->internal_id);
	my $leafText = $polar->text($leafL+$hi,$a,$textH/2,$leaf->id,class=>"leaf");
	
	# branch length
	_add_unrooted_branch_length($leaf,0,$leafL,$a,$par);

	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
		}

		if ($def->{label})
		{
			if ($def->{label}->{font})
			{
				my $label = $def->{label}->{font};
				$leafText->setAttribute("-cdata",$label);
			}

			if ($def->{label}->{color})
			{
				$leafText->setAttribute("style","fill:$def->{label}->{color}");
			}
		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};
			my $style = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
			my $label = $leafText->getAttribute("-cdata");
			my $textW = $font->fetch_text_width($label);
			my $theta1 = $a - $unitA/2;
			my $theta2 = $a + $unitA/2;
			my $r2 = $leafL + $textW + $hi;
			my $r1 = $defconf->{cover} eq "label" ? $leafL + $hi : 0;
			$polar->parent($range);
			$polar->fan($r1,$theta1,$r2,$theta2,class=>"range",style=>$style);
			$polar->parent($parent);
		}
	}
}

*_add_unrooted_branch_length = \&_add_circular_branch_length;

# add bootstrap in unrooted tree
sub _add_unrooted_bootstrap
{
	my ($node,$r,$a,$line,$par) = @_;
	
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $conf = $par->{conf};
	return if (! defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	my $bootstrap = $node->bootstrap;
	return unless defined $bootstrap;
	
	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$bootstrap,class=>"bootstrap");
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$symbol,class=>"bootstrap");
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line->setAttribute("style","stroke:$color");
	}
}

# draw unrooted tree done
#-------------------------------------------------------------------------------

#--------------------------------------------------------
# sub functions for public 
#--------------------------------------------------------
# get the tree top longest branch length
# used to align the branch id texts
sub tree_length
{
	my $rootNode = shift;
	my $conf = shift;
	
	return $rootNode->height if (defined $rootNode->height && ! $conf->{ignore_branch_length});

	my $hash;
	$hash = _tree_depth($rootNode,0,$hash);
	my @len = values %$hash;
	return max(\@len) + 1;
}

sub _tree_depth
{
	my $rootNode = shift;
	my $depth = shift;
	my $hash = shift;

	foreach my$node($rootNode->each_Descendent)
	{
		if ($node->is_Leaf)
		{
			$hash->{$node->internal_id} = $depth + 1;
		}
		else
		{
			$hash = _tree_depth($node,$depth+1,$hash);
		}
	}

	return $hash;
}

# get the branch length of node, 
# if not defined, will return 1 (2 for leaf node)
# if ignore_branch_length is set, will return 1 (2 for leaf node)
sub _get_branch_length
{
	my ($node,$conf) = @_;

	my $bl = 0;
	if ($conf->{ignore_branch_length} || ! defined $node->branch_length)
	{
		$bl = $node->is_Leaf ? 2 : 1; 	
	}
	else
	{
		$bl = $node->branch_length;
	}
	return $bl;
}

# get the bootstrap symbol 
sub _get_symbol
{
	my ($str,$bs) = @_;
	my @arr = split /\s+/ , $str;

	map {
		my ($sta,$end,$symbol) = split /,/ , $_;
		return $symbol if ($sta<$bs && $bs<=$end);
	} @arr;

	return "";
}

# get the bootstrap symbol 
sub _get_color
{
	my ($str,$bs) = @_;
	my @arr = split /\s+/ , $str;

	map {
		my ($sta,$end,$color) = split /,/ , $_;
		return SBV::Colors::fetch_color($color) if ($sta<$bs && $bs<=$end);
	} @arr;

	return "";
}

# load definition files
sub _load_defs
{
	my $conf = shift;
	my $trans = shift;
	my $defs;
	
	my $align = $conf->{align};
	$conf = $conf->{definition};

	return {} if (! $conf);
	
	$defs = read_tree_color_defs($conf->{color},$trans,$align,$defs) if ($conf->{color});
	$defs = read_tree_leaf_defs($conf->{leaf},$trans,$defs) if ($conf->{leaf});
	
	return $defs;
}

# load datasets files
sub _load_datasets
{
	my ($conf,$trans) = @_;
	my @datasets = ();
	
	return () if (! $conf->{datasets});
	$conf = SBV::CONF::fetch_first_conf("datasets",$conf,0);

	return () if (! $conf->{dataset});
	
	# init parameter
	if (ref $conf->{dataset} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{dataset}})
		{
			my $dataset = _load_dataset($conf,$subconf,$trans);
			push @datasets , $dataset if (defined $dataset);
		}
	}
	elsif (ref $conf->{dataset} eq "HASH")
	{
		my $dataset = _load_dataset($conf,$conf->{dataset},$trans);
		push @datasets , $dataset if (defined $dataset);
	}

	return @datasets;
}

sub _load_dataset
{
	my ($conf,$subconf,$trans) = @_;
	my $dataset = undef;

	if (! defined $subconf->{file})
	{
		WARN("the dataset file is not exists, will be skiped!");
		return $dataset;
	}
	
	my $file = check_path($subconf->{file});

	# init parameter
	my $type  = $subconf->{type} || $conf->{type};
	my $format = $subconf->{format} || $conf->{format}; # just for modify
	my $color = $subconf->{color} || $conf->{color};
	my $width = $subconf->{width} || $conf->{width};
	my $height = $subconf->{height} || $conf->{height};
	my $header = $subconf->{header} || $conf->{header};
	my $show = exists $subconf->{show} ? $subconf->{show} : 1;
	my $scale = $subconf->{scale} || $conf->{scale};
	my @color = split /[\s\,\t]+/ , $color;
	@color = map { SBV::Colors::fetch_color($_) } @color;
	$dataset->{type} = $type;
	$dataset->{color} = \@color;
	$dataset->{width} = $width;
	$dataset->{height} = $height;
	$dataset->{format} = $format;
	$dataset->{show} = $show;
	$dataset->{scale} = $scale;

	# read the dataset file 
	if ($type eq "marker")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		$dataset->{border} = $subconf->{border} || 0;
		
		my @allVal = map { $data->{row}->{$_}->[0] } @rownames;
		my $max = $subconf->{gradient} ? max(\@allVal) : 0;
		my $min = $subconf->{gradient} ? min(\@allVal) : 0;

		foreach my$name(@rownames)
		{
			my $val = $data->{row}->{$name}->[0];
			
			if ($subconf->{gradient})
			{
				$val = SBV::Colors::fetch_gradient_color(($val-$min)/($max-$min),$color[0],"#ffffff");
			}
			else
			{
				$val = SBV::Colors::fetch_color ($val);
			}
			
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $val } @inids;
		}
	}
	elsif ($type eq "pie")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"pie",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}
	elsif ($type eq "modify")
	{
		my $data = SBV::DATA->new(-file=>$file,-format=>$format);
		my @rownames = $data->names;
		$dataset->{bgline} = $subconf->{bgline} || 0;

		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			next if ($#inids > 0);
			map { $dataset->{data}->{$_} = $data->{$name} } @inids;
		}
	}
	elsif ($type eq "heatmap")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		$data->scale(scale=>$scale);
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}
	elsif ($type eq "boxplot")
	{
		my $data = SBV::DATA->new(-file=>$file,-format=>$format);
		my @rownames = $data->names;

		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			next if ($#inids > 0);
			map { $dataset->{data}->{$_} = $data->{$name} } @inids;
		}
	}
	else
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}

	return $dataset;
}

# trans the key id to internal_id
sub _trans_key
{
	my ($key,$type,$trans,$align) = @_;
	#$align = 1 if (! defined $align);

	if ($key =~ /(.+)\|(.+)/) # the key is two id
	{
		my $node1 = $trans->{$1};
		my $node2 = $trans->{$2};

		while(my$newNode1 = $node1->ancestor)
		{
			while(my$newNode2 = $node2->ancestor)
			{
				if ($newNode1 eq $newNode2)
				{
					my @subNodes = $newNode1->get_all_Descendents;
					my @leaves = grep {$_->is_Leaf} @subNodes;

					if ($type eq "clade")
					{
						my @internal_ids = map {$_->internal_id} @subNodes;
						push @internal_ids , $newNode1->internal_id;
						return @internal_ids;
					}
					elsif ($type eq "range")
					{
						if ($align == 1)
						{
							return $newNode1->internal_id;	
						}
						else
						{
							my @internal_ids = map {$_->internal_id} @leaves;
							return @internal_ids; 
						}
					}
					elsif ($type eq "label")
					{
						my @internal_ids = map {$_->internal_id} @leaves;
						return @internal_ids;
					}
					else # HGT
					{
						return $newNode1->internal_id;
					}
				}
				$node2 = $newNode2;
			}
			$node1 = $newNode1;
		}

		return ();
	}
	elsif ($trans->{$key}) # the key is id, return internal_id
	{
		return ($trans->{$key}->internal_id);
	}
	else # the key is internal id
	{
		return ($key);
	}
}

#-------------------------------------------------------------------------------
#  Name: read_tree_color_defs
#  Func: read the tree color definition file
#  The file should be tab separated plain text file with the following fields:
#  NODE_ID	TYPE	COLOR	[LABEL]
#-------------------------------------------------------------------------------
sub read_tree_color_defs
{
	my ($file,$trans,$align,$res) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		my @arr = split /\t/;
		my @internal_ids = _trans_key($arr[0],$arr[1],$trans,$align);
		$arr[2] = SBV::Colors::fetch_color($arr[2]);
		
		if (2 == $#arr)
		{
			map { $res->{$_}->{$arr[1]}->{color} = $arr[2]; } @internal_ids;
		}
		elsif (3 == $#arr)
		{
			map { $res->{$_}->{$arr[1]}->{color} = $arr[2]; } @internal_ids;
			map { $res->{$_}->{$arr[1]}->{label} = $arr[3]; } @internal_ids;
		}
		else
		{
			WARN('colnum_num_err');
			next;
		}
	}
	close FH;
	
	return $res;
}

#-------------------------------------------------------------------------------
#  Name: read_tree_leaf_defs
#  Func: read tree leaf definition file, used to set the leaf labels' text, font 
#  style and font weight
#-------------------------------------------------------------------------------
sub read_tree_leaf_defs
{
	my ($file,$trans,$res) = @_;
	$file = check_path($file);

	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		my ($name,$font,$style) = split /\t/;
		my @inids = _trans_key($name,'font',$trans);
		map { 
			$res->{$_}->{label}->{font} = $font; 
			$res->{$_}->{label}->{style} = $style if ($style);
		} @inids;

	}
	close FH;

	return $res;
}

#-------------------------------------------------------------------------------
#  Name: reroot_tree
#  Func: re define the tree root (reset the outgroup)
#-------------------------------------------------------------------------------
sub reroot_tree
{
	my ($tree,$node) = @_;

	#my @nodes = $tree->get_root_node->each_Descendent;
	my $root = $tree->get_root_node;
	#return $tree if $root eq $node;

	my ($ancestor,$collateral) = _identify_child($root,$node);

	my $father = _fetch_father($root);
	my $clade = $father->{$node};
	$root->remove_all_Descendents; # set new null root node
	$root->add_Descendent($node); # add node to new root 
	$root->add_Descendent($clade);

	while($clade != $ancestor)
	{
		$clade->add_Descendent($father->{$clade});
		$clade = $father->{$clade};
	}
	$clade->add_Descendent($collateral);
	
	return $tree;
}

sub _fetch_father
{
	my @parent = @_;
	my %hash;
	
	while($#parent >= 0)
	{
		my @newpar;
		foreach my$clade (@parent)
		{
			my @children = 	$clade->each_Descendent;
			for my$child(@children)
			{
				$hash{$child} = $clade;
				push @newpar , $child if (! $child->is_Leaf);
			}
		}
		@parent = @newpar;
	}

	return \%hash;
}

sub _identify_child
{
	my ($root,$node) = @_;
	
	my ($node1,$node2) = $root->each_Descendent;

	my @nodes = $node1->get_all_Descendents;
	push @nodes , $node1;

	my $flag = 0;
	for (@nodes) 
	{ 
		if ($_ == $node )
		{ 
			$flag = 1; last; 
		}
	}
	
	if (1 == $flag)
	{
		return ($node1,$node2);	
	}
	else
	{
		return ($node2,$node1);
	}
}
