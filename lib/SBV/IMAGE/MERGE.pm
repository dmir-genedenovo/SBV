package SBV::IMAGE::MERGE;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-10-23 14:26:11     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::MERGE -- a module used to draw a merged stat map with a same axis

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-10-23 14:26:11

=cut

use strict;
use warnings;
require Exporter;

use Math::Round;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::DEBUG;
use SBV::STAT;

sub new 
{
	my ($class,$names,$conf) = @_;
	my $object = {};
	
	my %trans = map {$names->[$_] => $_} 0 .. $#$names;
	$object->{names} = $names;
	$object->{conf} = $conf;
	$object->{id_trans} = \%trans;

	bless $object , $class;
	return $object;
}

sub plot
{
	my ($self,$parent,$model) = @_;
	$model ||= "horizontal";
	
	my $child = $parent->group();
	if ($model eq "horizontal")
	{
		$self->horizontal_plot($child);
	}
	else
	{
		$self->vertical_plot($child);
	}
}

sub horizontal_plot
{
	my ($self,$parent) = @_;
	my @names = @{$self->{names}};
	my $conf = $self->{conf};
	my $trans = $self->{id_trans};
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $defs = _load_defs($conf,$trans);
	my @datasets = _load_datasets($conf,$trans);
		
	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
	}
	
	# get the ids width 
	my @ids = map { 
		if(defined $defs->{$trans->{$_}}->{label}->{font}){
			$defs->{$trans->{$_}}->{label}->{font}
		} else { $_ } 
	} @names;
	
	my $font = SBV::Font->fetch_font("default");
	my $id_width = $conf->{hide_names} ? 0 : $font->fetch_max_text_width(\@ids);

	# get the blank width and check it
	my $blankW = $conf->{tw} - $id_width - 2*$hi - $dataWidth;
	ERROR("tree_width_err") if ($blankW < -8);

	my $unitH = $conf->{th} / ($#names + 1);
	my $textH = $font->fetch_text_height;
	
	# draw the id labels
	my $x = $conf->{ox} + $id_width + $hi;
	my $y = $conf->{oty} + $unitH/2 + $textH/2;
	for ( 0 .. $#names )
	{
		last if ($conf->{hide_names});
		if (my$def=$defs->{$_})
		{
			if ($def->{range})
			{
				$parent->rect(x=>$conf->{ox},y=>$conf->{oty}+$_*$unitH,
					width=>$id_width+$hi,height=>$unitH,
					style=>"fill:$def->{range}->{color};stroke-width:0");
			}
		}

		my $textW = $font->fetch_text_width($ids[$_]);
		my $label = $parent->text(x=>$x-$textW,y=>$y)->cdata($ids[$_]);
	
		if (my$def = $defs->{$_})
		{
			if($def->{label})
			{
				if ($def->{label}->{color})
				{
					$label->setAttribute("style","fill:$def->{label}->{color}");
				}
			}

		}

		$y += $unitH;
	}

	# draw datasets 
	my $axis = SBV::STONE::AXIS->new(ox=>$conf->{ox},oy=>$conf->{oty},length=>$conf->{th},
		angle=>90,tick=>"-1 $#names 1",start=>0,translate=>0.5,parent=>$parent);
	$axis->plot(show_tick_line=>0,show_tick_label=>0);
	
	my %func = (
		marker     => \&_add_marker,
		bar        => \&_add_bar,
		simple_bar => \&_add_simple_bar,
		multi_bar  => \&_add_multi_bar,
		circles    => \&_add_circles,
		boxplot    => \&_add_boxplot,
		connection => \&_add_connection,
		heatmap    => \&_add_heatmap,
		modify     => \&_add_modify,
		taxonomy   => \&_add_taxonomy
	);

	$x = $id_width + 2*$hi;
	foreach my $dataset(@datasets)
	{
		if ($dataset->{type} ne "taxonomy")
		{
			&{$func{$dataset->{type}}}($dataset,$x,$axis,'horizontal') if ($dataset->{show} == 1);
		}
		else 
		{
			_add_taxonomy($dataset,$conf,$x,$#names+1,$parent);
		}
		$x += $dataset->{width} + $hi * 2;
	}
}

sub vertical_plot
{
	my ($self,$parent) = @_;
	my @names = @{$self->{names}};
	my $conf = $self->{conf};
	my $trans = $self->{id_trans};
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $defs = _load_defs($conf,$trans);
	my @datasets = _load_datasets($conf,$trans);
	
	# get the datasets sum height (contain the internal gap)
	my $dataHeight = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataHeight += $_->{width} + 2*$hi;
		}
	}
	
	# get the ids width 
	my @ids = map { 
		if(defined $defs->{$trans->{$_}}->{label}->{font}){
			$defs->{$trans->{$_}}->{label}->{font}
		} else { $_ } 
	} @names;
	
	my $font = SBV::Font->fetch_font("default");
	my $labelHeight = $font->fetch_max_text_width(\@names);

	# get the blank height and check it
	my $blankH = $conf->{th} - $labelHeight - 2*$hi - $dataHeight;
	ERROR("tree_width_err") if ($blankH <= 0);

	my $unitW = $conf->{tw} / ($#names + 1);
	my $textW = $font->fetch_text_height;
	
	# draw the id labels
	my $angle = exists $conf->{label_angle} ? $conf->{label_angle} :  -90;
	my $x = $conf->{ox} + $unitW/2 + $textW/2;
	my $y = $conf->{oy} - $hi - $labelHeight;
	for (0 .. $#names)
	{
		last if ($conf->{hide_names});
		if (my $def = $defs->{$_})
		{
			if ($def->{range})
			{
				$parent->rect(x=>$conf->{ox}+$_*$unitW,y=>$conf->{oy}-$labelHeight-$hi,
					width=>$unitW,height=>$labelHeight+$hi,
					style=>"fill:$def->{range}->{color};stroke-width:0");
			}
		}
		
		my $textY = $y + $font->fetch_text_width($ids[$_]);
		my $label;
		
		if ($angle != 0)
		{
			$label = $parent->text(x=>$x,y=>$textY,transform=>"rotate($angle,$x,$textY)")->cdata($ids[$_]);
		}
		else 
		{
			my $textX = $x - $textW/2 - $font->fetch_text_width($ids[$_])/2;
			$textY = $conf->{oy} - $hi - $labelHeight/2 + $textW/2;
			$label = $parent->text(x=>$textX,y=>$textY)->cdata($ids[$_]);
		}
		
		if (my $def = $defs->{$_})
		{
			if ($def->{label}->{color})
			{
				$label->setAttribute("style","fill:$def->{label}->{color}");
			}
		}

		$x += $unitW;	
	}

	# draw datasets
	my $axis = SBV::STONE::AXIS->new(ox=>$conf->{ox},oy=>$conf->{oy},length=>$conf->{tw},
		side=>"right",tick=>"-1 $#names 1",start=>0,translate=>0.5,parent=>$parent);
	$axis->plot(show_tick_line=>0,show_tick_label=>0);
	
	my %func = (
		marker     => \&_add_marker,
		bar        => \&_add_bar,
		simple_bar => \&_add_simple_bar,
		multi_bar  => \&_add_multi_bar,
		circles    => \&_add_circles,
		boxplot    => \&_add_boxplot,
		connection => \&_add_connection,
		heatmap    => \&_add_heatmap,
		modify     => \&_add_modify
	);

	$y = $labelHeight + 2*$hi + $blankH + $hi;
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$y,$axis,'vertical') if ($dataset->{show} == 1);
		$y += $dataset->{width} + $hi * 2;
	}
		
}

sub _add_marker
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $class = $dataset->{border} ? "selector" : "marker";
	my $height = $axis->{unit} * $dataset->{height};
	
	foreach my$id(sort {$a<=>$b} keys %{$dataset->{data}})
	{
		my $fill = $dataset->{data}->{$id};
		my $style = "fill:$fill;stroke-width:0;";
		
		my $rectx = $axis->fetch_dis($id-0.5) - $height/2;
		my $recty = 0-$x-$width;

		$axis->{group}->rect(x=>$rectx,y=>$recty,
			width=>$height,height=>$width,style=>$style);
	}
}

# just for horizontal plot 
sub _add_taxonomy
{
	my ($dataset,$conf,$x,$num,$parent) = @_;
	my $width = $dataset->{width};
	my $height = $conf->{th};

	my $layer1 = $dataset->{layer1};
	my $layer2 = $dataset->{layer2};
	my $layer3 = $dataset->{layer3};
	my $data = $dataset->{data};
	my $taxonomy = $dataset->{taxonomy};
	
	my $font = SBV::Font->fetch_font("default");
	my $textH = $font->fetch_text_height();
	
	my $unitH = nearest 0.01 ,  ($height / $num);
	my $hi = $SBV::conf->{hspace};
	my $space = $conf->{taxonomy_space} || 10;

	# draw labels 
	my %yloci;
	foreach my$i (0 .. $#$layer3)
	{
		my $textx = $x + 4*$hi;
		my $texty = $conf->{oty} + ($i+0.5) * $unitH + $textH/2;
		$parent->text(x=>$textx,y=>$texty)->cdata($layer3->[$i]);
		
		$yloci{$layer3->[$i]} = $texty - $textH/2;
	}
	
	# draw layer2 
	my $max_width1 = $font->fetch_max_text_width($layer3);
	my $textx = $x + 4*$hi + $max_width1 + $hi + $space;
	my $x2 = $textx - $hi;
	foreach my$i ( 0 .. $#$layer2)
	{
		my $father = $taxonomy->{$layer2->[$i]}->{layer1};
		my $first = $data->{$father}->{$layer2->[$i]}->[0];
		my $last  = $data->{$father}->{$layer2->[$i]}->[-1];
		my $texty = ($yloci{$first} + $yloci{$last})/2 + $textH/2;
		$parent->text(x=>$textx,y=>$texty)->cdata($layer2->[$i]);

		$yloci{$layer2->[$i]} = $texty - $textH/2;
		
		# draw link line 
		if ($first eq $last)
		{
			my $textW = $font->fetch_text_width($first);
			my $x1 = $x + 4*$hi + $textW + $hi;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$texty - $textH/2,y2=>$texty - $textH/2,style=>"stroke-width:1");
		}
		else 
		{
			my $textW = $font->fetch_text_width($first);
			my $x1 = $x + 4*$hi + $textW + $hi;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$yloci{$first},y2=>$yloci{$first},style=>"stroke-width:1");
			
			$textW = $font->fetch_text_width($last);
			$x1 = $x + 4*$hi + $textW + $hi;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$yloci{$last},y2=>$yloci{$last},style=>"stroke-width:1");
			
			$parent->line(x1=>$x2,x2=>$x2,y1=>$yloci{$first},y2=>$yloci{$last},style=>"stroke-width:2");
		}
	}

	# draw layer1 
	my $max_width2 = $font->fetch_max_text_width($layer2);
	$textx = $x + 4*$hi + $max_width1 + $hi + $max_width2 + $hi + $space*2;
	$x2 = $textx - $hi;
	foreach my$i ( 0 .. $#$layer1)
	{
		my @vals = sort {$a<=>$b} map { $yloci{$_} } keys %{$data->{$layer1->[$i]}};
		my $texty = ($vals[0] + $vals[-1])/2 + $textH/2;
		$parent->text(x=>$textx,y=>$texty)->cdata($layer1->[$i]);
		
		my @labels = sort {$yloci{$a} <=> $yloci{$b}} keys %{$data->{$layer1->[$i]}};
		my $first = $labels[0];
		my $last = $labels[-1];
		if ($#labels == 0)
		{
			my $textW = $font->fetch_text_width($first);
			my $x1 = $x + 4*$hi + $max_width1 + $space + $hi + $textW + $hi;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$texty - $textH/2,y2=>$texty - $textH/2,style=>"stroke-width:1");
		}
		else 
		{
			my $textW = $font->fetch_text_width($first);
			my $x1 = $x + 4*$hi + $max_width1 + $space + $hi + $textW + $hi;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$yloci{$first},y2=>$yloci{$first},style=>"stroke-width:1");
			
			$textW = $font->fetch_text_width($last);
			$x1 = $x + 4*$hi + $max_width1 + $space + $hi + $textW + $hi;;
			$parent->line(x1=>$x1,x2=>$x2,y1=>$yloci{$last},y2=>$yloci{$last},style=>"stroke-width:1");
			
			$parent->line(x1=>$x2,x2=>$x2,y1=>$yloci{$first},y2=>$yloci{$last},style=>"stroke-width:2");
		}
	}
}

sub _add_bar
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	
	# create the val axis 
	my @sum = map { sum($_) } values %{$dataset->{data}};
	my $max = max(\@sum);
	my $tick = SBV::STAT::dividing(0,$max);
	my $val_axis = SBV::STONE::AXIS->new(parent=>$parent,ox=>0,oy=>0-$x,angle=>-90,
		length=>$width,	side=>"left",start=>0,translate=>0,tick=>$tick,bone=>1);
	$val_axis->plot;

	foreach my$id(keys %{$dataset->{data}})
	{
		my $rectx = $axis->fetch_dis($id-0.5) - $height/2;
		my $recty = 0-$x;
		my $i = 0;
		foreach my$num (@{$dataset->{data}->{$id}})
		{
			my $rectw = nearest 0.01 , $val_axis->fetch_dis($num);
			$recty -= $rectw;
			my $color = loop_arr(\@color,$i);
			$parent->rect(x=>$rectx,y=>$recty,width=>$height,height=>$rectw,
				style=>"fill:$color",class=>"marker");
			$i ++;
		}
	}
}

sub _add_simple_bar
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	
	# create val axis 
	my @nums = map { $_->[0] } values %{$dataset->{data}};
	my $tick = SBV::STAT::dividing(\@nums,-xtrue=>1);
	my $val_axis = SBV::STONE::AXIS->new(parent=>$parent,ox=>0,oy=>0-$x,angle=>-90,
		length=>$width,start=>0,translate=>0,side=>'left',tick=>$tick,bone=>1);
	$val_axis->plot;
	
	my $i = 0;
	foreach my$id(sort keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);
		my $num = $dataset->{data}->{$id}->[0];
		my $rectw = nearest 0.01 , $val_axis->fetch_dis($num);
		my $rectx = $axis->fetch_dis($id-0.5) - $height/2;
		my $recty = 0 - $x - $rectw;
		$parent->rect(x=>$rectx,y=>$recty,width=>$height,height=>$rectw,
			style=>"fill:$color",class=>"marker");
		$i ++;
	}

}

sub _add_multi_bar
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}}; 
	my $bar_num = scalar @{$values[0]};
	my $bar_width = nearest 0.01 , ($width / $bar_num);

	for my$index (0 .. $bar_num-1)
	{
		my $color = loop_arr(\@color,$index);

		# create the val axis
		my @nums = map { $_->[$index] } values %{$dataset->{data}};
		my $tick = SBV::STAT::dividing(\@nums,-xtrue=>1);
		my $val_axis = SBV::STONE::AXIS->new(parent=>$parent,ox=>0,oy=>0-$x-$index*$bar_width,
			length=>$bar_width,start=>0,translate=>0,tick=>$tick,side=>"left",bone=>1,angle=>-90);
		$val_axis->plot;

		foreach my$id(keys %{$dataset->{data}})
		{
			my $num = $dataset->{data}->{$id}->[$index];
			my $rectw = nearest 0.01 , ($val_axis->fetch_dis($num));
			my $rectx = $axis->fetch_dis($id-0.5) - $height/2;
			my $recty = 0-$x-$index*$bar_width-$rectw;
			$parent->rect(x=>$rectx,y=>$recty,width=>$height,height=>$rectw,
				style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_modify
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	my $hi = $SBV::conf->{hspace};
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $usex = $axis->fetch_dis($id-0.5);
		if ($dataset->{format} eq "domain")
		{
			$parent->line(x1=>$usex,x2=>$usex,y1=>0-$x,y2=>0-$x-$width,class=>"bgline"); 
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($len,$sta,$end,$shape,$color,$fill,$label) = @$modify;
				my $usew = ($end-$sta+1)/$len * $width; 
				my $usey = 0 - $x - $end/$len*$width;
				my $susex = $usex - $usew/2;
				$usey = $usey + $usew/2 - $height/2;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				my $rx = $susex + $usew/2;
				my $ry = $usey + $height/2;
				$parent->group(transform=>"rotate(-90,$rx,$ry)")->use(
					x=>$susex,y=>$usey,width=>$usew,height=>$height,'-href'=>"#$symid");
			}
		}
		elsif ($dataset->{format} eq "symbol")
		{
			my $i = 0;
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($shape,$color,$fill,$label) = @$modify;
				my $usew = $height;
				my $usey = 0 - $x - $height - ($height+$hi)*$i;
				my $susex = $usex - $usew/2;
				$usey = $usey + $usew/2 - $height/2;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				my $rx = $susex + $usew/2;
				my $ry = $usey + $height/2;
				$parent->group(transform=>"rotate(-90,$rx,$ry)")->use(
					x=>$susex,y=>$usey,width=>$usew,height=>$height,'-href'=>"#$symid");
				$i ++;
			}
		}
	}
}

sub _add_circles
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $circle_num = scalar @{$values[0]};
	my $space = ($width - $circle_num * $height) / ($circle_num - 1);
	my @nums = map { $_->[0] } @values;
	my $max = max(\@nums);

	for my$index (0 .. $circle_num-1)
	{
		my $color = loop_arr(\@color,$index);
		foreach my$id(keys %{$dataset->{data}})
		{
			my $cy = nearest 0.01 , 0 - ($x + $index * ($space + $height) + $height/2);
			my $cx = $axis->fetch_dis($id) - $height/2;
			my $r = nearest 0.01 , ($height/2 * $dataset->{data}->{$id}->[$index] / $max);
			$parent->circle(cx=>$cx,cy=>$cy,r=>$r,style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_heatmap
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @colors = @{ $dataset->{color} };

	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = defined $dataset->{max} ? $dataset->{max} : max(\@nums);
	my $min = defined $dataset->{min} ? $dataset->{min} : min(\@nums);
	my $block_width = $width/$col_num;
	my $scale = $dataset->{scale} || "none";
	
	# fetch the column min and max ( for scale == column )
	my (@cmin,@cmax);
	if ($scale eq "column")
	{
		foreach my$i (0 .. $col_num-1)
		{
			my @temp = map { $_->[$i] } @values;
			push @cmin , min(\@temp);
			push @cmax , max(\@temp);
		}
	}

	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		
		if ($scale eq "row")
		{
			$min = min(\@vals);
			$max = max(\@vals);
		}
		
		my $rectx = $axis->fetch_dis($id-0.5) - $height/2;
		foreach my$index(0 .. $#vals)
		{
			if ($scale eq "column")
			{
				$min = $cmin[$index];
				$max = $cmax[$index];
			}

			my $recty = 0 - $x - ($index+1) * $block_width;
			
			my ($ratio,$color);

			if ($max != $min)
			{
				$ratio = ($vals[$index]-$min)/($max-$min);
				$color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			}
			else 
			{
				$color = "none";
			}

			$parent->rect(x=>$rectx,y=>$recty,width=>$height,height=>$block_width,
				style=>"fill:$color",class=>"heatmap");
		}
	}
		
}

sub _add_boxplot
{
	my ($dataset,$x,$axis) = @_;
	my $width = $dataset->{width};
	my $height = $axis->{unit} * $dataset->{height};
	my $parent = $axis->{group};
	my @color = @{ $dataset->{color} };
	
	my @nums;
	map { splice(@nums,0,0,@$_) } values %{$dataset->{data}};
	my $tick = SBV::STAT::dividing(\@nums);
	my $val_axis = SBV::STONE::AXIS->new(parent=>$parent,ox=>0,oy=>0-$x,angle=>-90,
		length=>$width,start=>0,translate=>0,side=>'left',tick=>$tick,bone=>1);
	$val_axis->plot;
	
	my$i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);

		my @val = @{ $dataset->{data}->{$id} };
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;
		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;

		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}

		my $x2 = $axis->fetch_dis($id-0.5);
		my $x1 = $x2 - $height/2;
		my $x3 = $x2 + $height/2;
		
		my $q3y = 0 - $x - $val_axis->fetch_dis($q1);
		my $q2y = 0 - $x - $val_axis->fetch_dis($q2);
		my $q1y = 0 - $x - $val_axis->fetch_dis($q3);
		my $upy = 0 - $x - $val_axis->fetch_dis($lowval);
		my $lowy = 0 - $x - $val_axis->fetch_dis($upval);
		my $w = ($q3y-$q1y);
		
		$parent->rect(x=>$x1,y=>$q1y,height=>$w,width=>$height,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(x1=>$x1,y1=>$q2y,x2=>$x3,y2=>$q2y,
			style=>{stroke=>$color,'stroke-width'=>2});
		$parent->line(x1=>$x2,x2=>$x2,y1=>$q3y,y2=>$upy,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(x1=>$x2,x2=>$x2,y1=>$q1y,y2=>$lowy,
			style=>{stroke=>$color,'stroke-width'=>1});

		foreach my$i (@abnormal)
		{
			my $iy = 0 - $x - $val_axis->fetch_dis($i);
			$parent->circle(cx=>$x2,cy=>$iy,r=>2,style=>{fill=>$color,'stroke-width'=>0});
		}

		$i++;
	}
}

sub _load_defs
{
	my $conf = shift;
	my $trans = shift;
	my $defs;

	my $align = 1;
	$conf = $conf->{definition};

	return {} if (! $conf);

	$defs = read_tree_color_defs($conf->{color},$trans,$align,$defs) if ($conf->{color});
	$defs = read_tree_leaf_defs($conf->{leaf},$trans,$defs) if ($conf->{leaf});

	return $defs;
}

sub _load_datasets
{
	my ($conf,$trans) = @_;
	my @datasets = ();

	return () if (! $conf->{datasets});
	$conf = SBV::CONF::fetch_first_conf("datasets",$conf,0);

	return () if (! $conf->{dataset});

	if (ref $conf->{dataset} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{dataset}})
		{
			my $dataset = _load_dataset($conf,$subconf,$trans);
			push @datasets , $dataset if (defined $dataset);
		}
	}
	elsif (ref $conf->{dataset} eq "HASH")
	{
		my $dataset = _load_dataset($conf,$conf->{dataset},$trans);
		push @datasets , $dataset if (defined $dataset);
	}

	return @datasets;
}

sub _load_dataset
{
	my ($conf,$subconf,$trans) = @_;
	my $dataset = undef;
	
	if (! defined $subconf->{file})
	{
		WARN("the dataset file is not exists, will be skiped!");
		return $dataset;
	}
	
	# init parameter
	my $type  = $subconf->{type} || $conf->{type};
	my $format = $subconf->{format} || $conf->{format}; # just for modify
	my $color = $subconf->{color} || $conf->{color};
	my $width = $subconf->{width} || $conf->{width};
	my $height = $subconf->{height} || $conf->{height};
	my $show = exists $subconf->{show} ? $subconf->{show} : 1;
	my $header = $subconf->{header} || $conf->{header};
	my $rownames = $subconf->{rownames} || $conf->{rownames};
	my $scale = $subconf->{scale} || $conf->{scale};
	my @colors = split /[\s\,\t]+/ , $color;
	@colors = map { SBV::Colors::fetch_color($_) } @colors;
	$dataset->{type} = $type;
	$dataset->{color} = \@colors;
	$dataset->{width} = $width;
	$dataset->{height} = $height;
	$dataset->{format} = $format;
	$dataset->{show} = $show;
	$dataset->{min} = $subconf->{min} if (defined $subconf->{min});
	$dataset->{max} = $subconf->{max} if (defined $subconf->{max});
	$dataset->{scale} = $scale;

	# read the dataset file
	my $file = check_path($subconf->{file});

	if ($type eq "marker")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		$dataset->{border} = $subconf->{border} || 0;
		my @allVal = map { $data->{$_}->[0] } @rownames;
		my $max = $subconf->{gradient} ? max(\@allVal) : 0;
		my $min = $subconf->{gradient} ? min(\@allVal) : 0;
		foreach my$name(@rownames)
		{
			my $val = $data->{row}->{$name}->[0];
			if ($subconf->{gradient})
			{
				$val = SBV::Colors::fetch_gradient_color(($val-$min)/($max-$min),$colors[0],"#ffffff");	
			}
			else
			{
				$val = SBV::Colors::fetch_color ($val);	
			}

			my $id = $trans->{$name};
			$dataset->{data}->{$id} = $val;
		}
	}
	elsif ($type eq "modify")
	{
		my $data = SBV::DATA->new(-file=>$file,-format=>$format);
		my @rownames = $data->names;
		$dataset->{bgline} = $subconf->{bgline} || 0;

		foreach my$name(@rownames)
		{
			my $id = $trans->{$name};
			$dataset->{data}->{$id} = $data->{row}->{$name};
		}
	}
	elsif ($type eq "heatmap")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		$data->scale(scale=>$scale);
		foreach my$name(@rownames)
		{
			my $id = $trans->{$name};
			$dataset->{data}->{$id} = $data->{row}->{$name};
		}
	}
	elsif ($type eq "taxonomy")
	{
		my $temp = SBV::DATA->new(-file=>$file,-format=>"taxonomy");
		my @data = @$temp;
		my @layer1;
		my @layer2;
		my @layer3; # ids
		my %taxonomy;

		my %hash1;
		my %hash2;
		my $data = {};
		foreach my$i(@data)
		{
			my ($id,$layer1,$layer2) = @$i;
			push @layer3 , $id;
			push @layer2 , $layer2 unless $hash2{$layer2};
			push @layer1 , $layer1 unless $hash1{$layer1};
			$hash1{$layer1} = 1;
			$hash2{$layer2} = 1;

			push @{$data->{$layer1}->{$layer2}} , $id;
			$taxonomy{$id}{layer1} = $layer1;
			$taxonomy{$id}{layer2} = $layer2;
			$taxonomy{$layer2}{layer1} = $layer1;
		}
		

		$dataset->{layer1} = \@layer1;
		$dataset->{layer2} = \@layer2;
		$dataset->{layer3} = \@layer3;
		$dataset->{data} = $data;
		$dataset->{taxonomy} = \%taxonomy;
	}
	else
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		foreach my$name(@rownames)
		{
			my $id = $trans->{$name};
			$dataset->{data}->{$id} = $data->{row}->{$name};
		}
	}

	return $dataset;
}

#-------------------------------------------------------------------------------
#  Name: read_tree_color_defs
#  Func: read the tree color definition file
#  The file should be tab separated plain text file with the following fields:
#  NODE_ID	TYPE	COLOR	[LABEL]
#-------------------------------------------------------------------------------
sub read_tree_color_defs
{
	my ($file,$trans,$align,$res) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		my @arr = split /\t/;
		my $id = $trans->{$arr[0]};
		$arr[2] = SBV::Colors::fetch_color($arr[2]);
		
		if (2 == $#arr)
		{
			$res->{$id}->{$arr[1]}->{color} = $arr[2];
		}
		elsif (3 == $#arr)
		{
			$res->{$id}->{$arr[1]}->{color} = $arr[2];
			$res->{$id}->{$arr[1]}->{label} = $arr[3];
		}
		else
		{
			WARN('colnum_num_err');
			next;
		}
	}
	close FH;
	
	return $res;
}

#-------------------------------------------------------------------------------
#  Name: read_tree_leaf_defs
#  Func: read tree leaf definition file, used to set the leaf labels' text, font 
#  style and font weight
#-------------------------------------------------------------------------------
sub read_tree_leaf_defs
{
	my ($file,$trans,$res) = @_;
	$file = check_path($file);

	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		my ($name,$font,$style) = split /\t/;
		$font =~ s/\s+$//;
		my $id = $trans->{$name};
		$res->{$id}->{label}->{font} = $font;
		$res->{$id}->{label}->{style} = $style if ($style);
	}
	close FH;

	return $res;
}
