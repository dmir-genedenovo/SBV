package SBV::IMAGE::KARYO;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-11-04 15:06:23     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::KARYO -- the module to draw karyotype figure

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-11-04 15:06:23

=cut


use strict;
use warnings;
require Exporter;

use Math::Round;
use Math::Cephes qw(:trigs);
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::STAT;
use SBV::DEBUG;
use SBV::CONF;
use SBV::Constants;

sub new 
{
	my ($class,$data,$conf) = @_;
	my $object = {};
	
	$object->{data} = $data;
	$object->{conf} = $conf;

	bless $object , $class;
	return $object;
}

sub plot
{
	my ($self,$parent,%opts) = @_;
	my $conf = $self->{conf};
	$self->{parent} = $parent;
	my $model = $opts{model} || $conf->{model};
		
	SBV::DRAW::background($conf,$parent);
	my $group = $parent->group(id=>"karyo$SBV::idnum");
	$SBV::idnum ++;
	$self->{group} = $group;

	if ($model eq "normal" || $model eq "horizontal")
	{
		$self->normal_karyo("normal");	
	}
	elsif ($model eq "vertical")
	{
		$self->normal_karyo("vertical");
	}
	elsif ($model eq "circular")
	{
		$self->circular_karyo;
	}
	
	#chrlocJS();
	
	# add legend
	if ($conf->{legend})
	{
		my $legend = SBV::STONE::LEGEND->new(conf=>$conf->{legend});
		$legend->location($conf);
		$legend->draw($parent);
	}
}

sub chrlocJS
{
	my $js = <<JS;
var svgdoc;
var svgns = "http://www.w3.org/2000/svg";
var isIE = document.all?true:false;
var prompt;
var line;
var group; 
var link;

function hlg_onmouseover(evt,y1,y2,label)
{
	svgdoc = evt.target.ownerDocument;
	line = evt.target;
	group = line.parentElement;
	line.setAttribute("style","stroke:#f00;stroke-width:3");
	var x = line.getAttribute("x1");

	prompt = svgdoc.createElementNS(svgns,"g");
	group.appendChild(prompt);

	link =  svgdoc.createElementNS(svgns,"line");
	link.setAttribute("x1",x);
	link.setAttribute("x2",x);
	link.setAttribute("y1",y1);
	link.setAttribute("y2",y2);
	link.setAttribute("style","stroke:#f00;stroke-width:2");
	prompt.appendChild(link);
}

function hlg_onmouseout(evt)
{
	svgdoc = evt.target.ownerDocument;
	line.setAttribute("style","stroke:#000;stroke-width:2");
	prompt.removeChild(link);
	group.removeChild(prompt);
}
JS
	$SBV::svg->script(type=>"text/javascript")->CDATA($js);
}

sub normal_karyo
{
	my $self = shift;
	my $model = shift;
	my $conf = $self->{conf};
	my $data = $self->{data};
	my $parent = $self->{group};
	
	# load datasets 
	my $ideogram = $conf->{ideogram};
	$data = parse_ideogram($data,$ideogram);
	$data = parse_ticks($data,$conf);
	$data = parse_highlights($data,$conf);
	
	my @links = parse_links($conf);
	my @plots = parse_plots($conf);
	
	my @chrorder = fetch_chromosomes_order($data,$ideogram);
	my @chrsize = map { $data->{$_}->{size} } @chrorder;
	
	# set the width and height
	my $karyoW = $conf->{tw};
	my $karyoH = $conf->{th};
	my $ox = $conf->{ox};
	my $oty = $conf->{oty};
	my $cx = $conf->{ox} + $karyoW/2;
	my $cy = $conf->{oty} + $karyoH/2;
	
	if ($model eq "vertical")
	{
		$parent->setAttribute("transform","rotate(90,$cx,$cy)");
		($karyoW,$karyoH) = ($karyoH,$karyoW);
		$ox = $cx - $karyoW/2;
		$oty = $cy - $karyoH/2;
	}

	my $chr_unit_h = $karyoH / ($#chrorder+1);
	my ($chr_label_w,$chr_label_h) = fetch_chr_label_size($data,\@chrorder,$ideogram);
	my $hspace = $SBV::conf->{hspace};
	my $label_font = SBV::Font->fetch_font('chr_label');
	my $zoom = ($karyoW - $chr_label_w - $hspace*3)/max(\@chrsize);
	my $thickness = $ideogram->{thickness};
	my $start = SBV::CONF::fetch_size($conf->{start},$chr_unit_h);

	$conf->{orientation} = "left";
	if ($conf->{orientation} eq "left")
	{
		my $y = nearest 0.01 , ($oty + $start);
		my $x = $ox;
		my $rectx = nearest 0.01 , ($x + $chr_label_w + $hspace*2);
		foreach my$chr(@chrorder)
		{
			$data->{$chr}->{ycoord} = $y;
			my $reverse = $data->{$chr}->{reverse};
			
			# draw label 
			if ($ideogram->{show_label} && $ideogram->{show})
			{
				my $label = $ideogram->{label_with_tag} ? $data->{$chr}->{label} : $chr;
				my ($textx,$texty);

				if ($ideogram->{label_parallel})
				{
					$textx = $x + $chr_label_w - $label_font->fetch_text_width($label) + $hspace;
					$texty = $y + $chr_label_h/2;
					$parent->text(class=>"chr_label",x=>$textx,y=>$texty)->cdata($label);
				}
				else
				{
					$textx = $x + $chr_label_w + $hspace;
					$texty = $y + $chr_label_h/2;
					$parent->text(class=>"chr_label",x=>$textx,y=>$texty,transform=>"rotate(-90,$textx,$texty)")->cdata($label);
				}
			}
			
			my $upy = $y - $thickness/2;
			my $downy = $y + $thickness/2;
			my $width = nearest 0.01 , $zoom * $data->{$chr}->{size};
			$data->{$chr}->{upcoord} = $upy;
			$data->{$chr}->{downcoord} = $downy;
			$data->{$chr}->{width} = $width;
			
			# draw tick
			my$ticks = $data->{$chr}->{ticks};
			if ($ticks && $ideogram->{show})
			{
				foreach my$tick (@$ticks)
				{
					my $orientation = $tick->{orientation} || "up";
					my $offset = $tick->{offset} || 0;
					my $size = $tick->{size};
					my $bone = 0 == $offset ? 0 : 1;
					my $transx = $rectx;
					my $transy;
					my $side;

					if ($orientation eq "up")
					{
						$transy = $upy - $offset;
						$side = "left";
					}
					elsif ($orientation eq "down")
					{
						$transy = $downy + $offset;
						$side = "right";
					}
					else
					{
						ERROR('ticks_orientation_err',$orientation);
					}
					
					my $min_tick = 0;
					my $start = 0;

					if ($data->{$chr}->{sta} > 1 && $tick->{show_true_ticks})
					{
						$min_tick = int ($data->{$chr}->{sta} * $tick->{label_multiplier} + 1);
						$start = ($min_tick - $data->{$chr}->{sta} * $tick->{label_multiplier})/($tick->{spacing}*$tick->{label_multiplier});
					}

					my $tickObj = $parent->group(class=>"ticks",transform=>"translate($transx,$transy)");
					my $axis = SBV::STONE::AXIS->new(ox=>0,oy=>0,length=>$width,bone=>$bone,
						size=>$size,start=>$start,show_tick_label=>$tick->{show_label},side=>$side,
						tick=>"$min_tick $data->{$chr}->{size} $tick->{spacing}",skip_first_tick=>0,unit_label=>$tick->{unit_label},
						multiple=>$tick->{label_multiplier},parent=>$tickObj,theme=>$tick->{tick_label_theme});
					
					if ($reverse)
					{
						#my $label_theme = "angle:-180";
						my $label_theme = "$tick->{tick_label_theme}" if ($tick->{tick_label_theme});
						$side = $side eq "left" ? "right" : "left";
						$axis->aes(ox=>$width,angle=>180,side=>$side,theme=>$label_theme);
					}

					$axis->plot();
				}
			}
			
			# draw chr ideogram
			my $fill = $ideogram->{chromosomes_color} ? $data->{$chr}->{color} : "none";
			my $recty = $upy;
			my $rx = $ideogram->{chromosomes_rounded_ends} ? $thickness/2 : 0;
			my $ry = $rx;
			$parent->rect(x=>$rectx,y=>$recty,width=>$width,height=>$thickness,rx=>$rx,ry=>$ry,
				style=>"fill:$fill;stroke-width:1;stroke:#000",class=>"ideogram") if ($ideogram->{show});
			
			# draw highlights
			if (my$highlights = $data->{$chr}->{highlights})
			{
				foreach my$hl (@$highlights)
				{
					my ($hl_x,$hl_y,$hl_w,$hl_h,$shape);

					if ($hl->{ideogram})
					{
						$hl_y = $upy;
						$hl_h = $thickness;
					}
					else
					{
						my ($loc0,$loc1) = ($hl->{loc0},$hl->{loc1});
						$loc0 = $loc0 < 0  ? $upy + $loc0 : $downy + $loc0;
						$loc1 = $loc1 < 0  ? $upy + $loc1 : $downy + $loc1;
						($loc0,$loc1) = ($loc1,$loc0) if ($loc0 > $loc1);
						$hl_y = $loc0;
						$hl_h = $loc1 - $loc0;
					}

					my ($sta,$end) = ($hl->{start},$hl->{end});
					$hl_x = 0 == $reverse ? cal_coord($data,$chr,$sta,$zoom,$rectx) : cal_coord($data,$chr,$end,$zoom,$rectx);
					$hl_w = cal_dis($sta,$end,$zoom); 
					
					if ($sta == $end)
					{
						$hl_w = $hl->{radius} ? $hl->{radius} * 2 : 8;
						$hl_x -= $hl_w/2;
					}

					delete $hl->{width};
					delete $hl->{height};
					my $symid = SBV::STONE::SYMBOL::new($hl->{shape},width=>$hl_w,height=>$hl_h,%$hl);
					my $hlg = $parent->group(class=>"highlights")->use(x=>$hl_x,y=>$hl_y,width=>$hl_w,height=>$hl_h,'-href'=>"#$symid");
				}
			}
			
			$y = nearest 0.01 , ($y + $chr_unit_h);
		}

		# draw links 
		my $linksObj = $parent->group(class=>"links");
		foreach my$link (@links)
		{
			my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = @$link;
			my $x1 = cal_coord($data,$chr1,$sta1,$zoom,$rectx);
			my $x2 = cal_coord($data,$chr1,$end1,$zoom,$rectx);
			my $x3 = cal_coord($data,$chr2,$end2,$zoom,$rectx);
			my $x4 = cal_coord($data,$chr2,$sta2,$zoom,$rectx);
			my $y1 = $data->{$chr1}->{ycoord};
			my $y2 = $data->{$chr2}->{ycoord};

			if ($y1 < $y2)
			{
				$y1 += $attrs->{loc0};
				$y2 -= $attrs->{loc1};
			}
			else
			{
				$y1 -= $attrs->{loc0};
				$y2 += $attrs->{loc1};
			}
			
			my @xcoord = ($x1,$x2,$x3,$x4);
			my @ycoord = ($y1,$y1,$y2,$y2);
			SBV::DRAW::area(\@xcoord,\@ycoord,parent=>$linksObj,%$attrs);
		}

		# draw plots
		my $plotsObj = $parent->group(class=>"plots");
		foreach my$plot(sort {$a->{z} <=> $b->{z}} @plots)
		{
			my $plotObj = $plotsObj->group(class=>"plot");

			foreach my$chr(keys %{$plot->{data}})
			{
				next unless defined $data->{$chr}->{display};
				_add_plot($data,$plot,$chr,$zoom,$rectx,$plotObj);
			}
		}
	}
}

sub circular_karyo 
{
	my $self = shift;
	my $conf = $self->{conf};
	my $data = $self->{data};
	my $parent = $self->{group};
	my $vspace = $SBV::conf->{vspace};

	# load datasets 
	my $ideogram = $conf->{ideogram};
	$data = parse_ideogram($data,$ideogram);
	$data = parse_ticks($data,$conf);
	$data = parse_highlights($data,$conf);
	
	my @links = parse_links($conf);
	my @plots = parse_plots($conf);
	
	my @chrorder = fetch_chromosomes_order($data,$ideogram);
	my @chrsize = map { $data->{$_}->{size} } @chrorder;
	
	# 
	my $cx = $conf->{ox} + $conf->{tw}/2;
	my $cy = $conf->{oty} + $conf->{th}/2;

	my ($chr_label_w,$chr_label_h) = fetch_chr_label_size($data,\@chrorder,$ideogram);
	my $hspace = $SBV::conf->{hspace};
	my $label_font = SBV::Font->fetch_font('chr_label');
	my $label_h = $label_font->fetch_text_height;
	my $thickness = $ideogram->{thickness};

	my $Gsize = sum(\@chrsize); # whole genome size
	my $GCsize = $Gsize; # global cirle size
	my $leaf = $conf->{ideogram}->{spacing};
	
	for my$i(0 .. $#chrorder)
	{
		my $id1 = $chrorder[$i];
		my $id2 = $chrorder[$i+1] || $chrorder[0];
		my $spacing = ideogram_spacing($id1,$id2,$leaf,$Gsize);
		$GCsize += $spacing;
	}
	
	my $zoom = 360 / $GCsize;

	# draw 
	my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$parent);
	my $rotation = $conf->{rotation};
	my $radius = $conf->{radius};

	my $angle = $rotation;
	foreach my$i(0 .. $#chrorder)
	{
		my $id1 = $chrorder[$i];
		my $id2 = $chrorder[$i+1] || $chrorder[0];
		my $angle2 = $angle + $zoom * $data->{$id1}->{size};
		my $reverse = $data->{$id1}->{reverse};
		$data->{$id1}->{angle} = $angle;
		$data->{$id1}->{angle2} = $angle2;
		$data->{$id1}->{radius} = $radius unless $data->{$id1}->{radius};
		$data->{$id1}->{thickness} = $thickness unless $data->{$id1}->{thickness};
		my $outer_r = $data->{$id1}->{radius} + $data->{$id1}->{thickness}/2; 
		my $inner_r = $data->{$id1}->{radius} - $data->{$id1}->{thickness}/2;
		$data->{$id1}->{outer_r} = $outer_r;
		$data->{$id1}->{inner_r} = $inner_r;

		# draw ideogram
		my $fill = $ideogram->{chromosomes_color} ? $data->{$id1}->{color} : "none";
		my $style = "fill:$fill;stroke-width:1;stroke:#000";
		$polar->fan($outer_r,$angle,$inner_r,$angle2,style=>$style,class=>"ideogram") if ($ideogram->{show});
		
		# draw highlights
		if (my$highlights = $data->{$id1}->{highlights})
		{
			foreach my$hl (@$highlights)
			{
				my ($r0,$r1);
				if ($hl->{ideogram})
				{
					$r0 = $outer_r;
					$r1 = $inner_r;
				}
				else
				{
					$r0 = SBV::CONF::fetch_size($hl->{r0},$radius);
					$r1 = SBV::CONF::fetch_size($hl->{r1},$radius);
				}
				
				my $sta = cal_coord($data,$id1,$hl->{start},$zoom,$angle);
				my $end = cal_coord($data,$id1,$hl->{end},$zoom,$angle);
				($sta,$end) = ($end,$sta) if ($reverse == 1);

				my $fill = $hl->{fill} || "#000";
				$fill = SBV::Colors::fetch_color($fill);
				my $stroke = $hl->{color} || "#000";
				$stroke = SBV::Colors::fetch_color($stroke);
				my $style = "fill:$fill;stroke:$stroke";
				$polar->fan($r0,$sta,$r1,$end,class=>"highlights",style=>$style);
			}
		}
		
		# draw label 
		if ($ideogram->{show_label} && $ideogram->{show})
		{
			my $label = $ideogram->{label_with_tag} ? $data->{$id1}->{label} : $id1;
			my $label_r = SBV::CONF::fetch_size($ideogram->{'label_radius'},$radius);
			my $theta = $ideogram->{label_center} ? ($angle + $angle2)/2 : $angle;
			my $label_w = $label_font->fetch_text_width($label);

			if ($ideogram->{label_parallel})
			{
				$label_r -= $label_h if ($label_r < $radius);
				$polar->text($label_r,$theta,-$label_w/2,$label,class=>"chr_label",parallel=>1);
			}
			else
			{
				$label_r -= $label_w if ($label_r < $radius);
				$polar->text($label_r,$theta,-$label_h/2,$label,class=>"chr_label");
			}
		}
		
		# draw tick
		my$ticks = $data->{$id1}->{ticks};
		if ($ticks && $ideogram->{show})
		{
			foreach my$tick (@$ticks)
			{
				my $tick_font = SBV::Font->new($tick->{tick_label_theme});
				my $tick_h = $tick_font->fetch_text_height;

				my $orientation = $tick->{orientation};
				my $offset = $tick->{offset};
				my $tick_thick = $tick->{thickness};
				my $tick_size = $tick->{size};
				my $spacing = $tick->{spacing};
				my $label_multiplier = $tick->{label_multiplier};
				my $size = $tick->{size};
				my $unit_label = $tick->{unit_label} || "";

				if ($orientation eq "outer")
				{
					my $r0 = $outer_r + $offset;
					my $r1 = $r0 + $size;
					for (my$i = 0; $i<$data->{$id1}->{size}; $i+= $spacing)
					{
						my $tick_label = $i * $label_multiplier;
						$tick_label .= $unit_label;
						my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
						$polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

						if ($tick->{show_label} && $tick->{label_parallel})
						{
							my $tick_w = $tick_font->fetch_text_width($tick_label);
							$polar->text($r1+$vspace,$tick_theta,-$tick_w/2,$tick_label,
								parallel=>1,theme=>$tick->{tick_label_theme});
						}
						elsif ($tick->{show_label} && ! $tick->{label_parallel})
						{
							my $tick_w = $tick_font->fetch_text_width($tick_label);
							$polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
								parallel=>0,theme=>$tick->{tick_label_theme});
						}
					}
				}
				elsif ($orientation eq "inner")
				{
					my $r0 = $inner_r - $offset;
					my $r1 = $r0 - $size;

					for (my$i = 0; $i<$data->{$id1}->{size}; $i+= $spacing)
					{
						my $tick_label = $i * $label_multiplier;
						$tick_label .= $unit_label;
						my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
						$polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

						if ($tick->{show_label})
						{
							my $tick_w = $tick_font->fetch_text_width($tick_label);
							$polar->text($r1-$vspace-$tick_h,$tick_theta,-$tick_w/2,$tick_label,
								theme=>$tick->{tick_label_theme},parallel=>1);
						}
						elsif ($tick->{show_label} && ! $tick->{label_parallel})
						{
							my $tick_w = $tick_font->fetch_text_width($tick_label);
							$polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
								parallel=>0,theme=>$tick->{tick_label_theme});
						}
					}
				}
			}
		}
		
		$angle = $angle2 + $zoom * ideogram_spacing($id1,$id2,$leaf,$Gsize);
	}
	
	# draw links
	my $linksObj = $parent->group(class=>"links");
	$polar->parent($linksObj);
	foreach my$link (@links)
	{
		my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = @$link;
		my $r0 = SBV::CONF::fetch_size($attrs->{r0},$radius);
		my $r1 = SBV::CONF::fetch_size($attrs->{r1},$radius);

		my $Qangle1 = cal_coord($data,$chr1,$sta1,$zoom,$data->{$chr1}->{angle});
		my $Qangle2 = cal_coord($data,$chr1,$end1,$zoom,$data->{$chr1}->{angle});
		my $Rangle1 = cal_coord($data,$chr2,$sta2,$zoom,$data->{$chr2}->{angle});
		my $Rangle2 = cal_coord($data,$chr2,$end2,$zoom,$data->{$chr2}->{angle});

		$polar->BCurve($r0,$Qangle1,$Qangle2,$r1,$Rangle1,$Rangle2,%$attrs);
	}

	# draw plots
	my $plotsObj = $parent->group(class=>"plots");
	foreach my$plot(sort {$a->{z} <=> $b->{z}} @plots)
	{
		my $plotObj = $plotsObj->group(class=>"plot");
		$polar->parent($plotObj);

		foreach my$chr(keys %{$plot->{data}})
		{
			next unless defined $data->{$chr}->{display};
			_add_circular_plot($data,$plot,$chr,$zoom,$polar);
		}
	}
}

sub ideogram_spacing
{
	my ($id1,$id2,$leaf,$Gsize) = @_;
	return 0 unless ($leaf);
	
	my $spacing = SBV::CONF::fetch_size($leaf->{default},$Gsize) || 0;
	
	if ($leaf->{pairwise}->{"$id1;$id2"} || $leaf->{pairwise}->{"$id2;$id1"})
	{
		my $tag = $leaf->{pairwise}->{"$id1;$id2"} ? "$id1;$id2" : "$id2;$id1";
		$spacing = SBV::CONF::fetch_size($leaf->{pairwise}->{"$tag"}->{spacing},$Gsize);
	}
	
	return $spacing;
}

# add plot to normal karyotype figure
sub _add_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent)	= @_;

	my $type = $plot->{type};
	my %func = (
		scatter   => \&_add_scatter_plot,
		line      => \&_add_line_plot,
		histogram => \&_add_histogram_plot,
		heatmap   => \&_add_heatmap_plot,
		text      => \&_add_text_plot,
	);
	
	ERROR('err_plot_type') unless defined $func{$type};

	my $child = $parent->group(class=>"$chr\_plot");
	&{$func{$type}}($data,$plot,$chr,$zoom,$ox,$child);
}

sub _add_scatter_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = defined $plot->{tick} ? $plot->{tick} :  SBV::STAT::dividing($min,$max,-xtrue=>1);
	my $show_tick_label = $plot->{show_tick_label} || 0;
	my $show_tick_line = $plot->{show_tick_line} || 0;
	my $show_axis_bone = $plot->{show_axis_bone} || 0;

	# create the y axis for val
	my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
	my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
	my $len = abs ($y1 - $y2);
	my $orientation = $y1 > $y2 ? "down" : "up";
	my $angle = $y1 > $y2 ? -90 : 90;
	my $axis = SBV::STONE::AXIS->new(
		bone => $show_axis_bone,
		ox=>$ox-10,oy=>$y1,length=>$len,
		tick=>$tick,
		angle=>$angle,
		start => 0,
		show_tick_label=>$show_tick_label,
		show_tick_line=>$show_tick_line,
		skip_first_tick => 0,
		skip_last_tick => 0,
		size=>8,
		side=>"left",
	);
	$axis->plot(parent=>$parent);
	add_background_and_axis($axis,$plot,$data->{$chr}->{width});

	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
		next if ($val > $max || $val < $min);
		my $dis = $axis->fetch_dis($val);
		my $y = $y1 < $y2 ? $y1 + $dis : $y1 - $dis;
		my $radius = $attrs->{radius} || 2;
		my $shape = defined $attrs->{shape} ? $attrs->{shape} : 1;
		
		if ($shape == 1)
		{
			$attrs->{color} ||= "#000";
			$attrs->{fill} ||= "none";
			my $color = SBV::Colors::fetch_color($attrs->{color});
			my $fill = SBV::Colors::fetch_color($attrs->{fill});
			$parent->circle(cx=>$x,cy=>$y,r=>$radius,
				style=>"fill:$fill;stroke:$color;stroke-width:$attrs->{stroke_width}");
		}
		else 
		{
			my $symid = SBV::STONE::SYMBOL::new($shape,width=>$radius*2,height=>$radius*2,%$attrs);
			$parent->group(class=>"scatter")->use(x=>$x-$radius,y=>$y-$radius,
				width=>$radius*2,height=>$radius*2,'-href'=>"#$symid");
		}
	}
}

sub _add_line_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
	
	my $show_tick_label = $plot->{show_tick_label} || 0;
	my $show_tick_line = $plot->{show_tick_line} || 0;

	# create the y axis for val
	my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
	my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
	my $len = abs ($y1 - $y2);
	my $orientation = $y1 > $y2 ? "down" : "up";
	my $angle = $y1 > $y2 ? -90 : 90;
	my $axis = SBV::STONE::AXIS->new(
		ox=>$ox,oy=>$y1,length=>$len,
		tick=>$tick,
		angle=>$angle,
		show_tick_label=>$show_tick_label,
		show_tick_line=>$show_tick_line,
		skip_first_tick => 0,
		skip_last_tick => 0,
		size=>8,
		side=>"left",
		#bgline=>$data->{$chr}->{width},
	);
	$axis->plot(parent=>$parent);
	add_background_and_axis($axis,$plot,$data->{$chr}->{width});

	my (@px,@py);
	foreach (sort {$a->[0] <=> $b->[0]} @$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
		next if ($val > $max || $val < $min);
		my $dis = $axis->fetch_dis($val);
		my $y = $y1 < $y2 ? $y1 + $dis : $y1 - $dis;
		push @px , $x;
		push @py , $y;
	}
	
	# set the default color and stroke width
	my $color = defined $plot->{color} ? $plot->{color} : "000";
	$color = SBV::Colors::fetch_color($color);
	my $swidth = defined $plot->{stroke_width} ? $plot->{stroke_width} : 1;

	my $points = $parent->get_path(x=>\@px,y=>\@py,-type=>'polyline');
	$parent->polyline(%$points,fill=>'none',style=>"stroke:$color;stroke-width:$swidth");
}

sub _add_histogram_plot_back
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
	my $show_tick_label = $plot->{show_tick_label} || 0;
	my $show_tick_line = $plot->{show_tick_line} || 0;
	
	# create the y axis for val
	my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
	my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
	my $len = abs ($y1 - $y2);
	my $orientation = $y1 > $y2 ? "down" : "up";
	my $angle = $y1 > $y2 ? -90 : 90;
	
	my $axis = SBV::STONE::AXIS->new(
		ox=>$ox,oy=>$y1,length=>$len,
		tick=>$tick,
		angle=>$angle,
		show_tick_label=>$show_tick_label,
		show_tick_line=>$show_tick_line,
		start => 0,
		skip_first_tick => 0,
		skip_last_tick => 0,
		size=>8,
		side=>"left",
		#bgline=>$data->{$chr}->{width},
	);
	$axis->plot(parent=>$parent);
	
	add_background_and_axis($axis,$plot,$data->{$chr}->{width});

	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
		my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
		my $x = $x1 > $x2 ? $x2 : $x1;
		my $barw = abs($x1-$x2);

		my $dis = $axis->fetch_dis($val);
		my $y = $y1 < $y2 ? $y1 : $y1 - $dis;
		
		my $style = SBV::CONF::fetch_styles(%$attrs);
		$parent->rect(x=>$x,y=>$y,width=>$barw,height=>$dis,style=>$style);
	}
		
}

sub _add_histogram_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
	my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
	
	if ($max <= 0)
	{
		$min = abs($min);
		$max = abs($max);
		($min,$max) = ($max,$min);
		@vals = map { abs($_) } @vals;
		($y1,$y2) = ($y2,$y1);
	}
	elsif ($min <= 0 && $max >= 0)
	{
		($y1,$y2) = ($y2,$y1) if ($y1>$y2);
	}


	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
	my $show_tick_label = $plot->{show_tick_label} || 0;
	my $show_tick_line = $plot->{show_tick_line} || 0;
	
	# create the y axis for val
	my $len = abs ($y1 - $y2);
	my $orientation = $y1 > $y2 ? "down" : "up";
	my $angle = $y1 > $y2 ? -90 : 90;
		
	my $axis = SBV::STONE::AXIS->new(
		ox=>$ox,oy=>$y1,length=>$len,
		tick=>$tick,
		angle=>$angle,
		show_tick_label=>$show_tick_label,
		show_tick_line=>$show_tick_line,
		start => 0,
		skip_first_tick => 0,
		skip_last_tick => 0,
		size=>8,
		side=>"left",
		#bgline=>$data->{$chr}->{width},
	);
	$axis->plot(parent=>$parent);
	
	add_background_and_axis($axis,$plot,$data->{$chr}->{width});

	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
		my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
		my $x = $x1 > $x2 ? $x2 : $x1;
		my $barw = abs($x1-$x2);

		my $dis = $axis->fetch_dis($val);
		my $y = $y1 < $y2 ? $y1 : $y1 - $dis;

		if ($max >= 0 && $min <=0)
		{
			if ($val > 0)
			{
				$dis = $axis->fetch_dis($val) - $axis->fetch_dis(0);
				$y = $y2;
			}
			else 
			{
				$dis = $axis->fetch_dis(0) - $axis->fetch_dis($val);
				$y = $y1 - $axis->fetch_dis(0);
			}
		}
		
		my $style = SBV::CONF::fetch_styles(%$attrs);
		$parent->rect(x=>$x,y=>$y,width=>$barw,height=>$dis,style=>$style);
	}
		
}

sub _add_heatmap_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
	
	my @fills = SBV::CONF::fetch_val($plot,"fill");
	@fills = map { SBV::Colors::fetch_color($_) } @fills;
	my $fill_unm = scalar @fills;

	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);

		# fetch x coord
		my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
		my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
		my $x = $x1 > $x2 ? $x2 : $x1;
		my $barw = abs($x1-$x2);
	
		# fetch loc0 and loc1 coord
		my $y1 = cal_y_coord($data,$chr,$attrs->{loc0});
		my $y2 = cal_y_coord($data,$chr,$attrs->{loc1});
		my $len = abs ($y1 - $y2);
		my $y = $y1 > $y2 ? $y2 : $y1;
		
		# get gradient color
		my $ratio = ($val - $min) / ($max - $min);
		my $index = int ($#fills * $ratio);
		my $fill = $#fills == 1 ? SBV::Colors::fetch_gradient_color($ratio,@fills) : $fills[$index];
		my $styles = SBV::CONF::fetch_styles(%$attrs,fill=>$fill);

		$parent->rect(x=>$x,y=>$y,width=>$barw,height=>$len,style=>$styles);
	}
}

sub _add_text_plot
{
	my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
	my $records = $plot->{data}->{$chr};
	$plot->{snuggle_layer} = 1 unless $plot->{snuggle_layer};
	
	my $flagx1 = 0;
	my $flagx2 = 0;
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	my $texty = 0;
	foreach (sort {$a->[0] <=> $b->[0]} @$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
		
		my $lineStyle;
		$lineStyle .= "stroke-width:$attrs->{link_thickness};" if ($attrs->{link_thickness});	
		$lineStyle .= "stroke:$attrs->{link_color};" if ($attrs->{link_color});
		
		if ($attrs->{ideogram_highlights})
		{
			my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);	
			my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
			($x1,$x2) = ($x2,$x1) if ($x1 > $x2);
			my $y1 = $data->{$chr}->{upcoord};
			my $y2 = $data->{$chr}->{downcoord};
			
			my $linky1 = $y1 - 20;
			my $linky2 = $y1;

			my $hlg = $parent->group(class=>"chrloc",
				onmousemove=>"hlg_onmouseover(evt,$linky1,$linky2,\'$val\');",
				onmouseout=>"hlg_onmouseout(evt);");
			my $line = $hlg->line(x1=>$x,x2=>$x,y1=>$y1,y2=>$y2);
			$line->setAttribute(style=>$lineStyle) if ($lineStyle);
		}

		# fetch loc0 and loc1 coord
		my $y1 = cal_y_coord($data,$chr,$attrs->{loc0});
		my $y2 = cal_y_coord($data,$chr,$attrs->{loc1});
		$attrs->{theme} = "angle:-90" unless ($attrs->{theme});	

		my $font = SBV::Font->new($attrs->{theme});
		my $textH = $font->fetch_text_height;
		my $textW = $font->fetch_text_width($val);
		($textW,$textH) = true_size($textW,$textH,$font->{'font-angle'});
		
		# draw text
		my $textx1 = $x - $textW/2;
		my $textx2 = $x + $textW/2;
		my $textx = $font->{'font-angle'} == -90 ? $textx2 : $textx1;
		my $overlap = 0;
		$overlap = 1 if ($textx1 >= $flagx1 && $textx1 <= $flagx2);
		$overlap = 1 if ($textx2 >= $flagx1 && $textx2 <= $flagx2);
		$overlap = 0 if ($plot->{allow_overlap});
		$flagx1 = $textx1 unless ($overlap);
		$flagx2 = $textx2 unless ($overlap);
		my $layer = 1;

		if ($attrs->{loc0} < 0)
		{
			my $linkLen = $y1 - $data->{$chr}->{downcoord} - $vi;
			$linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
			
			if ($overlap == 0)
			{
				$layer = 1;
				# draw label
				$texty = $y1 + $textH;
				my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
				SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty < $y2);

				# draw link
				if ($attrs->{show_links})
				{
					my $links = $parent->line(x1=>$x,x2=>$x,y1=>$y1-$vi,y2=>$y1-$vi-$linkLen);
					$links->setAttribute("style",$lineStyle) if ($lineStyle);
				}

				$texty += $vi;
			}
			else
			{
				$layer ++;
				next if ($layer > $plot->{snuggle_layer});
				
				# draw link
				if ($attrs->{show_links})
				{
					if ($texty + $linkLen < $y2)
					{
						my $links = $parent->line(x1=>$x,x2=>$x,y1=>$texty,y2=>$texty + $linkLen);
						$links->setAttribute("style",$lineStyle) if ($lineStyle);
					}
					$texty += $linkLen;
				}
				
				$texty += $vi;

				# draw label 
				$texty += $textH;
				my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
				SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty < $y2);
				$texty += $vi;
			}
		}
		else
		{
			my $linkLen = $data->{$chr}->{upcoord} - $y1 - $vi;
			$linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
			
			if (0 == $overlap)
			{
				$layer = 1;
				# draw label
				$texty = $y1;
				my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
				SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty - $textH > $y2);

				# draw link
				if ($attrs->{show_links})
				{
					my $links = $parent->line(x1=>$x,x2=>$x,y1=>$y1+$vi,y2=>$y1+$vi+$linkLen);
					$links->setAttribute("style",$lineStyle) if ($lineStyle);
				}

				$texty -= $vi;
				$texty -= $textH;
			}
			else
			{
				$layer ++;
				next if ($layer > $plot->{snuggle_layer});
				# draw link
				if ($attrs->{show_links})
				{
					if ($texty - $linkLen > $y2)
					{
						my $links = $parent->line(x1=>$x,x2=>$x,y1=>$texty,y2=>$texty - $linkLen);
						$links->setAttribute("style",$lineStyle) if ($lineStyle);
					}
					$texty -= $linkLen;
				}
				
				$texty -= $vi;

				# draw label 
				my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
				SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty - $textH > $y2);
				$texty -= $textH;
				$texty -= $vi;
			}
		}
	}
	
}

# add backgrounds and axes to plot (histogram,line,scatter)
sub add_background_and_axis
{
	my ($axis,$plot,$width) = @_;

	add_background($axis,$plot,$width) if ($plot->{backgrounds});
	add_axis($axis,$plot,$width) if ($plot->{axes});
} 

sub add_background
{
	my ($axis,$plot,$width) = @_;
	return unless $plot->{backgrounds}->{background};
	my @backgrounds = SBV::CONF::extract_conf($plot->{backgrounds},'background');
	my $parent = $axis->{parent};
	my $ox = $axis->{ox};
	
	foreach my$bg(@backgrounds)
	{
		my ($y0,$y1,$color);
		if (defined $bg->{y0} && $bg->{y0} > $axis->{min} && $bg->{y0} < $axis->{max})
		{
			$y0 = $bg->{y0};
		}
		else
		{
			$y0 = $axis->{min};
		}

		if (defined $bg->{y1} && $bg->{y1} > $axis->{min} && $bg->{y1} < $axis->{max})
		{
			$y1 = $bg->{y1};	
		}
		else
		{
			$y1 = $axis->{max};
		}

		my $ycoord0 = fetch_yaxis_coord($axis,$y0);
		my $ycoord1 = fetch_yaxis_coord($axis,$y1);
		my $recty = $ycoord0 > $ycoord1 ? $ycoord1 : $ycoord0;
		$color = $bg->{color} || "vvlgrey";
		$color = SBV::Colors::fetch_color($color);
		$parent->rect(x=>$ox,y=>$recty,width=>$width,height=>abs($ycoord0-$ycoord1),style=>"stroke-width:0;fill:$color");
	}
}

sub add_axis
{
	my ($yaxis,$plot,$width) = @_;
	return unless $plot->{axes}->{axis};
	my @axes = SBV::CONF::extract_conf($plot->{axes},'axis');
	my $parent = $yaxis->{parent};
	my $ox = $yaxis->{ox};
	
	foreach my$axis(@axes)
	{
		my ($y0,$y1,$color);
		if (defined $axis->{y0} && $axis->{y0} > $yaxis->{min} && $axis->{y0} < $yaxis->{max})
		{
			$y0 = $axis->{y0};
		}
		else
		{
			$y0 = $yaxis->{min};
		}

		if (defined $axis->{y1} && $axis->{y1} > $yaxis->{min} && $axis->{y1} < $yaxis->{max})
		{
			$y1 = $axis->{y1};	
		}
		else
		{
			$y1 = $yaxis->{max};
		}
		
		my $ycoord0 = fetch_yaxis_coord($yaxis,$y0);
		my $ycoord1 = fetch_yaxis_coord($yaxis,$y1);
		$color = $axis->{color} || "lgrey";
		$color = SBV::Colors::fetch_color($color);
		my $swidth = $axis->{thickness} || 1;
		my $spacing = $axis->{spacing};
		$spacing = SBV::CONF::fetch_size($spacing,abs($ycoord1-$ycoord0));

		my $style = "stroke:$color;stroke-width:$swidth";
		my $i;
		if ($ycoord0 > $ycoord1)
		{
			for ($i=$ycoord0;$i>=$ycoord1;$i-=$spacing)
			{
				$parent->line(x1=>$ox,x2=>$ox+$width,y1=>$i,y2=>$i,style=>$style);
			}
		}
		else
		{
			for ($i=$ycoord0;$i<$ycoord1+$spacing;$i+=$spacing)
			{
				$parent->line(x1=>$ox,x2=>$ox+$width,y1=>$i,y2=>$i,style=>$style);
			}
		}
	}

}

sub fetch_yaxis_coord
{
	my ($axis,$val) = @_;
	my $angle = $axis->{angle};
	my $oy = $axis->{oy};
	my $dis = $axis->fetch_dis($val);

	my $coord = $angle == -90 ? $oy - $dis : $oy + $dis;
	return $coord;
}

# add plot figure to circular karyo map
sub _add_circular_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $type = $plot->{type};
	
	my %func = (
		scatter   => \&_add_circular_scatter_plot,
		line      => \&_add_circular_line_plot,
		histogram => \&_add_circular_histogram_plot,
		heatmap   => \&_add_circular_heatmap_plot,
		text      => \&_add_circular_text_plot,
	);
	
	ERROR('err_plot_type') unless defined $func{$type};
	&{$func{$type}}($data,$plot,$chr,$zoom,$polar);
}

sub _add_circular_scatter_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

	my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	my $len = abs($r1 - $r0);
	
	add_circular_background_and_axis($plot,$polar,$data,$chr);

	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
		my $r = $r0 < $r1 ? $r0 + ($val-$min)*$len/($max-$min) : $r0 - ($val-$min)*$len/($max-$min); 
		my ($x,$y) = $polar->polar2pos($r,$a,"angle");
		my $radius = $attrs->{radius} || 2;
		my $shape = defined $attrs->{shape} ? $attrs->{shape} : 1;
		my $symid = SBV::STONE::SYMBOL::new($shape,width=>$radius*2,height=>$radius*2,%$attrs);
		$polar->{parent}->group(class=>"scatter")->use(x=>$x-$radius,y=>$y-$radius,
			width=>$radius*2,height=>$radius*2,'-href'=>"#$symid");
	}
}

sub _add_circular_line_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

	my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	my $len = abs($r1 - $r0);
	
	my (@px,@py);
	add_circular_background_and_axis($plot,$polar,$data,$chr);
	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
		my $r = $r0 < $r1 ? $r0 + ($val-$min)*$len/($max-$min) : $r0 - ($val-$min)*$len/($max-$min); 
		my ($x,$y) = $polar->polar2pos($r,$a,"angle");
		push @px , $x;
		push @py , $y;
	}
	
	my $color = defined $plot->{color} ? $plot->{color} : "000";
	$color = SBV::Colors::fetch_color($color);
	my $swidth = defined $plot->{stroke_width} ? $plot->{stroke_width} : 1;

	my $points = $polar->{parent}->get_path(x=>\@px,y=>\@py,-type=>'polyline');
	$polar->{parent}->polyline(%$points,fill=>'none',style=>"stroke:$color;stroke-width:$swidth");
}

sub _add_circular_histogram_plot_back
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

	my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	my $len = abs($r1 - $r0);
	
	add_circular_background_and_axis($plot,$polar,$data,$chr);
	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
		my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
		my $style = SBV::CONF::fetch_styles(%$attrs);
		
		if ($r0 < $r1)
		{
			my $r = $r0 + ($val-$min)*$len/($max-$min); 
			$polar->fan($r0,$a1,$r,$a2,style=>$style);
		}
		else
		{
			my $r = $r0 - ($val-$min)*$len/($max-$min);
			$polar->fan($r0,$a1,$r,$a2,style=>$style);
		}
	}
}

sub _add_circular_histogram_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);

	my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	
	if ($max<= 0)
	{
		@vals = map { abs($_) } @vals;
		($r0,$r1) = ($r1,$r0);
		$min = abs($min);
		$max = abs($max);
		($min,$max) = ($max,$min);
	}
	elsif ($max >=0 && $min <= 0)
	{
		($r0,$r1) = ($r1,$r0) if ($r0 > $r1);
	}

	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
	my $len = abs($r1 - $r0);
	
	add_circular_background_and_axis($plot,$polar,$data,$chr);
	foreach (@$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
		my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
		my $style = SBV::CONF::fetch_styles(%$attrs);

		if ($max >= 0 && $min <= 0)
		{
			my $r_mid = $r1 - ($max - 0)*$len/($max-$min);
			my $r = $r_mid + $val*$len/($max-$min);
			$polar->fan($r_mid,$a1,$r,$a2,style=>$style);
		}
		else 
		{
			if ($r0 < $r1)
			{
				my $r = $r0 + ($val-$min)*$len/($max-$min); 
				$polar->fan($r0,$a1,$r,$a2,style=>$style);
			}
			else
			{
				my $r = $r0 - ($val-$min)*$len/($max-$min);
				$polar->fan($r0,$a1,$r,$a2,style=>$style);
			}
		}
	}
}

sub _add_circular_heatmap_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	
	# get the min and max value of the data
	my @vals = map { $$_[2] } @$records;
	my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
	my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
	my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

	my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	my $len = abs($r1 - $r0);
	
	my @fills = SBV::CONF::fetch_val($plot,"fill");
	@fills = map { SBV::Colors::fetch_color($_) } @fills;
	my $fill_unm = scalar @fills;
	
	my $color = $plot->{color} || "000";
	$color = SBV::Colors::fetch_color($color);
	my $swidth = $plot->{stroke_width} || 1;
	
	foreach ( @$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		next if ($val > $max || $val < $min);
		my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
		my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
		
		# get gradient color
		my $ratio = ($val - $min) / ($max - $min);
		my $index = int ($#fills * $ratio);
		my $fill = ( $#fills == 2 || $#fills == 1 ) ? SBV::Colors::fetch_gradient_color($ratio,@fills) : $fills[$index];
		my $style = "stroke:$fill;stroke-width:$swidth;fill:$fill";
		$polar->fan($r0,$a1,$r1,$a2,style=>$style);
	}
}

sub _add_circular_text_plot
{
	my ($data,$plot,$chr,$zoom,$polar) = @_;
	my $records = $plot->{data}->{$chr};
	$plot->{snuggle_layer} = 1 unless $plot->{snuggle_layer};

	my $flaga1 = 0;
	my $flaga2 = 0;
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	my $textr = 0;

	foreach (sort {$a->[0] <=> $b->[0]} @$records)
	{
		my ($sta,$end,$val,$attrs) = @$_;
		my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
		my $lineStyle;
		$lineStyle .= "stroke-width:$attrs->{link_thickness};" if ($attrs->{link_thickness});
		$lineStyle .= "stroke:$attrs->{link_color};" if ($attrs->{link_color});
		
		if ($attrs->{ideogram_highlights})
		{
			my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
			my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
			($a1,$a2) = ($a2,$a1) if ($a1>$a2);
			
			my $r1 = $data->{$chr}->{outer_r};
			my $r2 = $data->{$chr}->{inner_r};

			$polar->line($r1,$a,$r2,$a,style=>$lineStyle);
		}
		
		# fetch r0 and r1 coord
		my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
		my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
		$textr = $r0 if ($textr == 0);

		$attrs->{theme} = "angle:-90" unless ($attrs->{theme});

		my $font = SBV::Font->new($attrs->{theme});
		my $textH = $font->fetch_text_height;
		my $textW = $font->fetch_text_width($val);
		($textW,$textH) = true_size($textW,$textH,$font->{'font-angle'});
		
		my $trans = $font->{'font-angle'} ? $textW/2 : - $textW/2;
		my $parallel = $font->{'font-angle'} ? 0 : 1;

		# draw text
		my $texta1 = $a - 360*atan($textW/2/$textr)/$TWOPI;
		my $texta2 = $a + 360*atan($textW/2/$textr)/$TWOPI;
		my $texta = $a;
		my $overlap = 0;
		$overlap = 1 if ($texta1 >= $flaga1 && $texta1 <= $flaga2);
		$overlap = 1 if ($texta2 >= $flaga1 && $texta2 <= $flaga2);
		$flaga1 = $texta1 unless ($overlap);
		$flaga2 = $texta2 unless ($overlap);
		my $layer = 1;
			
		if ($r0 <= $data->{$chr}->{inner_r})
		{
			my $linkLen = $data->{$chr}->{inner_r} - $r0 - $vi;
			$linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
			
			if ($overlap == 0)
			{
				$layer = 1;
				# draw label
				$textr = $r0 - $textH;
				$polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme});

				# draw link
				if ($attrs->{show_links})
				{
					$polar->line($r0+$vi+$linkLen,$a,$r0+$vi,$a,style=>$lineStyle);
				}

				$textr -= $vi;
			}
			else
			{
				$layer ++;
				next if ($layer > $plot->{snuggle_layer});
				
				# draw link
				if ($attrs->{show_links})
				{
					if ($attrs->{show_links})
					{
						if ($textr - $linkLen > $r1)
						{
							$polar->line($textr,$a,$textr-$linkLen,$a,style=>$lineStyle);
						}
						$textr -= $linkLen;
					}
				}
				
				$textr -= $vi;
				$textr -= $textH;

				$polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme}) if ($textr > $r1);
				$textr -= $vi;
			}
		}
		elsif ($r0 >= $data->{$chr}->{outer_r})
		{
			my $linkLen = $r0 - $data->{$chr}->{outer_r} - $vi;
			$linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);

			if (0 == $overlap)
			{
				$layer = 1;

				# draw label
				$textr = $r0;
				$polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme});

				# draw link 
				if ($attrs->{show_links})
				{
					$polar->line($r0-$vi,$a,$r0-$vi-$linkLen,$a,style=>$lineStyle);
				}

				$textr += $vi;
				$textr += $textH;
			}
			else
			{
				$layer ++;
				next if ($layer > $plot->{snuggle_layer});

				# draw link
				if ($attrs->{show_links})
				{
					if ($textr + $linkLen < $r1)
					{
						$polar->line($textr,$a,$textr+$linkLen,$a,style=>$lineStyle);	
					}
					$textr += $linkLen;
				}
				
				$textr += $vi;
				# draw label 
				$polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme}) if ($textr + $textH > $r1);

				$textr += $textH;
				$textr += $vi;
			}
		}

	}
}

sub add_circular_background_and_axis
{
	my ($plot,$polar,$data,$chr) = @_;

	add_circular_background($plot,$polar,$data,$chr) if ($plot->{backgrounds});
	add_circular_axis($plot,$polar,$data,$chr) if ($plot->{axes});
}

sub add_circular_background
{
	my ($plot,$polar,$data,$chr) = @_;
	return unless $plot->{backgrounds}->{background};
	my @backgrounds = SBV::CONF::extract_conf($plot->{backgrounds},'background');
	my $parent = $polar->{parent};
		
	my $min = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $max = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	($min,$max) = ($max,$min) if ($min > $max);
	my $len = $max - $min;

	foreach my$bg(@backgrounds)
	{
		my $temp_y0 = $min + SBV::CONF::fetch_size($bg->{y0},$len) if (defined $bg->{y0});
		my $temp_y1 = $min + SBV::CONF::fetch_size($bg->{y1},$len) if (defined $bg->{y1});
		my ($y0,$y1,$color);
		if (defined $bg->{y0} && $temp_y0 > $min && $temp_y0 < $max)
		{
			$y0 = $temp_y0;
		}
		else
		{
			$y0 = $min;
		}

		if (defined $bg->{y1} && $temp_y1 > $min && $temp_y1 < $max)
		{
			$y1 = $temp_y1;	
		}
		else
		{
			$y1 = $max;	
		}
		
		$color = $bg->{color} || "vvlgrey";
		$color = SBV::Colors::fetch_color($color);

		$polar->fan($y0,$data->{$chr}->{angle},$y1,$data->{$chr}->{angle2},style=>"stroke-width:0;fill:$color");
	}
}

sub add_circular_axis
{
	my ($plot,$polar,$data,$chr) = @_;
	return unless $plot->{axes}->{axis};
	my @axes = SBV::CONF::extract_conf($plot->{axes},'axis');	
	
	my $min = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
	my $max = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
	($min,$max) = ($max,$min) if ($min > $max);
	my $len = abs($max - $min);
	
	foreach my$axis(@axes)
	{
		my $temp_y0 = $min + SBV::CONF::fetch_size($axis->{y0},$len) if (defined $axis->{y0});
		my $temp_y1 = $min + SBV::CONF::fetch_size($axis->{y1},$len) if (defined $axis->{y1});
		my ($y0,$y1,$color);
		if (defined $axis->{y0} && $temp_y0 > $min && $temp_y0 < $max)
		{
			$y0 = $temp_y0;
		}
		else
		{
			$y0 = $min;
		}

		if (defined $axis->{y1} && $temp_y1 > $min && $temp_y1 < $max)
		{
			$y1 = $temp_y1;	
		}
		else
		{
			$y1 = $max;	
		}
		
		$color = $axis->{color} || "lgrey";
		$color = SBV::Colors::fetch_color($color);
		my $swidth = $axis->{thickness} || 1;		
		my $spacing = $axis->{spacing};
		$spacing = SBV::CONF::fetch_size($spacing,$len);

		my $style = "stroke:$color;stroke-width:$swidth;fill:none";
		my $i;
		
		if ($y0 > $y1)
		{
			for ($i=$y0;$i>=$y1;$i-=$spacing)
			{
				$polar->pline($i,$data->{$chr}->{angle},$data->{$chr}->{angle2},style=>$style);	
			}
		}
		else
		{
			for ($i=$y0;$i<$y1+$spacing;$i+=$spacing)
			{
				$polar->pline($i,$data->{$chr}->{angle},$data->{$chr}->{angle2},style=>$style); 	
			}
		}
	}
}

#-------------------------------------------------------------------------------
# parse the ideogram conf to set the ideogram content
#-------------------------------------------------------------------------------
sub parse_ideogram
{
	my ($data,$conf) = @_;
	
	if ($conf->{show_chromosomes_default})
	{
		foreach my$chr(keys %$data)
		{
			$data->{$chr}->{display} = 1;
		}
	}

	if ($conf->{chromosomes})
	{
		my @records = split /;/ , $conf->{chromosomes};
		foreach my$record(@records)
		{
			my ($display,$chr) = $record =~ /([!-]?)(.+?)$/;
			$display = $display ? 0 : 1;
			$data->{$chr}->{display} = $display;
			delete $data->{$chr} unless ($display);
		}
	}

	if ($conf->{chromosomes_reverse})
	{
		my @chrs = split /;/ , $conf->{chromosomes_reverse};
		foreach my$chr(@chrs) { $data->{$chr}->{reverse} = 1 }
	}

	if ($conf->{chromosomes_break})
	{
		my @records = split /;/ , $conf->{chromosomes_break};
		foreach my$record(@records)
		{
			my ($chr,$region) = $record =~ /-([^:]+):(.+)/;	
			push @{ $data->{$chr}->{breaks} } , $region;
		}
	}

	return $data;
}

# parse the ideogram order from parameter or file
sub fetch_chromosomes_order
{
	my ($data,$conf) = @_;
	
	my @chrorder = sort { $data->{$a}->{display_order} <=> $data->{$b}->{display_order} } keys %$data;

	my @order;
	if ($conf->{chromosomes_order})
	{
		@order  = split /;/ , $conf->{chromosomes_order};
	}
	elsif ($conf->{chromosomes_order_file})
	{
		my $file = check_path($conf->{chromosomes_order_file});
		open FH,$file or die "can't open file $file $!";
		@order = <FH>;
		chomp @order;
		close FH;
	}
	
	if (@order)
	{
		my $fst = shift @order;
		my $index = aindex(\@chrorder,$fst);
		@chrorder = map { if (-1 == aindex(\@order,$_)){$_}else{undef} } @chrorder;
		splice(@chrorder,$index+1,0,@order);
	}
	
	@chrorder = grep {defined $_ && $data->{$_}->{display}} @chrorder;
	return @chrorder;
}

# fetch the chr label size
sub fetch_chr_label_size
{
	my ($data,$order,$conf) = @_;
	
	return (0,0) unless ($conf->{show_label});

	my $font = SBV::Font->fetch_font('chr_label');
	my $chr_label_h = $font->fetch_text_height;
	my @labels = $conf->{label_with_tag} ? map { $data->{$_}->{label} } @$order : @$order;
	my $chr_label_w = $font->fetch_max_text_width(\@labels);
	
	if ($conf->{label_parallel})
	{
		return ($chr_label_w,$chr_label_h);
	}
	else
	{
		return ($chr_label_h,$chr_label_w);	
	}
}

# parse ticks conf
sub parse_ticks
{
	my ($data,$conf) = @_;
	return $data unless ($conf->{ticks});
	
	my $ticks = SBV::CONF::fetch_first_conf('ticks',$conf);
	return $data unless ($ticks->{tick});

	if (ref $ticks->{tick} eq "ARRAY")
	{
		foreach my$tick (@{$ticks->{tick}})
		{
			$data = _parse_tick($data,$ticks,$tick);	
		}
	}
	elsif (ref $ticks->{tick} eq "HASH")
	{
		$data = _parse_tick($data,$ticks,$ticks->{tick});	
	}

	return $data;
}

sub _parse_tick
{
	my ($data,$conf,$subconf) = @_;

	# inherit attr from ticks
	foreach my$key (keys %$conf)
	{
		next if ($key eq "tick");
		$subconf->{$key} = $conf->{$key} unless $subconf->{$key};
	}
	
	my $show = {};
	if ($subconf->{chromosomes})
	{
		my @chrs = split /;/ , $subconf->{chromosomes};
		foreach my$chr (@chrs)
		{
			if ($chr =~ /^-/)	
			{
				$show->{$chr} = 0;
			}
			else
			{
				$show->{$chr} = 1;
			}
		}
	}
	else
	{
		$show->{$_} = 1 foreach (keys %$data);	
	}

	foreach my$chr(keys %$data)
	{
		push @{$data->{$chr}->{ticks}} , $subconf if ($show->{$chr});	
	}
	
	return $data;
}

# parse highlights 
sub parse_highlights
{
	my ($data,$conf) = @_;
	return $data unless ($conf->{highlights});
	$conf = SBV::CONF::fetch_first_conf("highlights",$conf);
	return $data unless ($conf->{highlight});
	
	if (ref $conf->{highlight} eq "ARRAY")
	{
		foreach my$subconf (@{$conf->{highlight}})
		{
			$data = _parse_highlight($data,$conf,$subconf);
		}
	}
	elsif (ref $conf->{highlight} eq "HASH")
	{
		$data = _parse_highlight($data,$conf,$conf->{highlight});
	}
	
	return $data;
}

sub _parse_highlight
{
	my ($data,$conf,$subconf) = @_;

	return $data unless $subconf->{file};
	my $file = check_path($subconf->{file});

	# inherit attr from ticks
	foreach my$key (keys %$conf)
	{
		next if ($key eq "tick");
		$subconf->{$key} = $conf->{$key} unless $subconf->{$key};
	}
	
	# read highlights file
	open FH,$file or die;
	while(<FH>)
	{
		chomp;
		next if (/^#/);
		next if ($_ eq "");
		my ($chr,$sta,$end,$attrs) = split;
		next unless ($data->{$chr});
		
		my $attrs_hash = {};
		foreach my$name(keys %$subconf)
		{
			$attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
		}

		($sta,$end) = ($end,$sta) if ($sta > $end);
		$attrs_hash->{start} = $sta;
		$attrs_hash->{end} = $end;
		
		if ($attrs)
		{
			my @attrs = split /;/ , $attrs;
			foreach my$attr(@attrs)
			{
				my ($name,$val) = split /=/ , $attr;
				$val = SBV::Colors::fetch_color($val) if ($name eq "color" || $name eq "fill");
				$attrs_hash->{$name} = $val;
			}
		}
		
		push @{$data->{$chr}->{highlights}} , $attrs_hash; 
	}
	close FH;
	
	return $data;
}

# parse links
sub parse_links
{
	my $conf = shift;
	return () unless $conf->{links};
	$conf = SBV::CONF::fetch_first_conf("links",$conf);
	return () unless $conf->{link};

	my @links = ();
	if (ref $conf->{link} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{link}})
		{
			_parse_link(\@links,$conf,$subconf);
		}
	}
	elsif (ref $conf->{link} eq "HASH")
	{
		_parse_link(\@links,$conf,$conf->{link});
	}

	return @links;
}

sub _parse_link
{
	my ($links,$conf,$subconf) = @_;

	return unless $subconf->{file};
	my $file = check_path($subconf->{file});

	# inherit attr from ticks
	foreach my$key (keys %$conf)
	{
		next if ($key eq "link");
		$conf->{$key} = SBV::Colors::fetch_color($conf->{$key}) if ($key eq "color" || $key eq "fill");
		$subconf->{$key} = $conf->{$key} unless $subconf->{$key};
	}

	# read links file
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		next if (/^#/);
		next if ($_ eq "");
		my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = split;
		
		my $attrs_hash = {};
		foreach my$name(keys %$subconf)
		{
			$attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
		}
		
		if ($attrs)
		{
			my @attrs = split /;/ , $attrs;
			foreach my$attr(@attrs)
			{
				my ($name,$val) = split /=/ , $attr;
				$val = SBV::Colors::fetch_color($val) if ($name eq "color" || $name eq "fill");
				$attrs_hash->{$name} = $val;
			}
		}
		
		push @$links , [$chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs_hash];
	}
	close FH;
}


#-------------------------------------------------------------------------------
#  parse the plots
#-------------------------------------------------------------------------------
sub parse_plots
{
	my ($conf) = @_;
	return () unless $conf->{plots};
	$conf = $conf->{plots};
	return () unless $conf->{plot};
	
	my @plots = ();
	if (ref $conf->{plot} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{plot}})
		{
			_parse_plot(\@plots,$conf,$subconf);
		}
	}
	elsif (ref $conf->{plot} eq "HASH")
	{
		_parse_plot(\@plots,$conf,$conf->{plot});
	}

	return @plots;
}

sub _parse_plot
{
	my ($plots,$conf,$subconf) = @_;
	
	return unless $subconf->{file};
	my $file = check_path($subconf->{file});
	
	# inherit attr from ticks
	foreach my$key (keys %$conf)
	{
		next if ($key eq "plot");
		$subconf->{$key} = $conf->{$key} unless $subconf->{$key};
	}
	
	ERROR('no_plot_type') unless $subconf->{'type'};
	
	# set the plot opts
	my $record = {};
	foreach my$name (keys %$subconf)
	{
		$record->{$name} = $subconf->{$name} unless ($name eq "file");	
	}
	$record->{z} = 0 unless defined $record->{z};

	# read plot file
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		next if (/^#/);
		next if ($_ eq "");

		my ($chr,$sta,$end,$val,$attrs) = split;

		my $attrs_hash = {};
		foreach my$name(keys %$subconf)
		{
			$attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
		}
		
		if ($attrs)
		{
			my @attrs = split /;/ , $attrs;
			foreach my$attr(@attrs)
			{
				my ($name,$val) = split /=/ , $attr;
				$attrs_hash->{$name} = $val;
			}
		}

		push @{$record->{data}->{$chr}} , [$sta,$end,$val,$attrs_hash];
	}
	close FH;

	push @$plots , $record;
}

#-------------------------------------------------------------------------------
# calculate the coord
sub cal_coord
{
	my ($data,$chr,$pos,$zoom,$x) = @_;
	my $width = $data->{$chr}->{size} * $zoom;

	$pos = ($pos - $data->{$chr}->{sta} + 1) * $zoom;
	my $reverse = $data->{$chr}->{reverse};
	my $coord = 0 == $reverse ? $x + $pos : $x + $width - $pos;
	return nearest 0.01 , $coord;
}

sub cal_y_coord
{
	my ($data,$chr,$loc) = @_;
	
	if ($loc < 0)
	{
		return $data->{$chr}->{downcoord} - $loc;	
	}
	else
	{
		return $data->{$chr}->{upcoord} - $loc;
	}
}

# calculate two position distance
sub cal_dis
{
	my ($pos1,$pos2,$zoom) = @_;
	return nearest 0.01 , $zoom * abs($pos2 - $pos1);
}
