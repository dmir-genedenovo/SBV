package SBV::Coordinate::RECTANG;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-06-25 14:16:29     |
#------------------------------------------------+
=pod

=head1 Name

SBV::Coordinate::RECTANG

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-06-25 14:16:29

=cut

use strict;
use warnings;
require Exporter;

use List::Util;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/../lib";

use SBV;
use SBV::STAT;
use SBV::Colors;
use SBV::DRAW;
use SBV::DEBUG;
use Math::Round;


#-------------------------------------------------------------------------------
#  create a new rectangular coordinate system
#  features:
#  ox,oy,width,height: which you can defined in conf, needed
#  parent: the svg object which you can draw the OS on it, needed
#-------------------------------------------------------------------------------
sub new 
{
	my $class = shift;
	my %param = @_;

	my $coord = {};
	$coord->{legend} = {};
	bless $coord , $class;
	$coord->aes(%param);
	return $coord;
}

sub check_features
{
	my $self = shift;

	ERROR('no_svg_object') unless (defined $self->{parent});
	ERROR('os_coord_err') unless (defined $self->{ox} && defined $self->{oy} && 
		defined $self->{tw} && defined $self->{th});
	ERROR('no_axis_limit') unless (defined $self->{xlim} && defined $self->{ylim});

	return 1;
}

# re load the datafile
sub read
{
	my ($self,$file,%param) = @_;
	$file = check_path($file);
	
	my $header = $param{header} || 0;
	my $rownames = $param{rownames} || 0;

	my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>$rownames);
	$self->{data} = $data;
}

sub labs
{
	my ($self,%param) = @_;
	$self->title($param{title}) if (exists $param{title});
	$self->xlab($param{x}) if (exists $param{x});
	$self->ylab($param{y}) if (exists $param{y});
}

sub title
{
	my ($self,$str) = @_;
	my $font = SBV::Font->fetch_font('CLASStitle');
	my $textH = $font->fetch_text_height;

	if ($str && ! defined $self->{title})
	{
		$self->{th} -= $textH + $SBV::conf->{vspace}*2;
		$self->{title} = $str;
	}
	elsif ($str && defined $self->{title})
	{
		$self->{title} = $str;	
	}
	elsif (defined $self->{title})
	{
		$self->{th} += $textH + $SBV::conf->{vspace}*2;
		$self->{title} = undef;
	}
}

sub xlab
{
	my ($self,$str) = @_;
	my $font = SBV::Font->fetch_font('CLASSsubtitle');
	my $textH = $font->fetch_text_height;

	if ($str && ! defined $self->{xlab})
	{
		$self->{th} -= $textH + $SBV::conf->{vspace}*2;
		$self->{oy} -= $textH + $SBV::conf->{vspace}*2;
		$self->{xlab} = $str;
	}
	elsif ($str && defined $self->{xlab})
	{
		$self->{xlab} = $str;	
	}
	elsif (defined $self->{xlab})
	{
		$self->{th} += $textH + $SBV::conf->{vspace}*2;
		$self->{oy} += $textH + $SBV::conf->{vspace}*2;
		$self->{xlab} = undef;
	}
}

sub ylab
{
	my ($self,$str) = @_;
	my $font = SBV::Font->fetch_font('CLASSsubtitle');
	my $textH = $font->fetch_text_height;
	
	if ($str && ! defined $self->{ylab})
	{
		$self->{tw} -= $textH + $SBV::conf->{hspace}*2;	
		$self->{ox} += $textH + $SBV::conf->{hspace}*2;
		$self->{ylab} = $str;
	}
	elsif ($str && defined $self->{ylab})
	{
		$self->{ylab} = $str;	
	}
	elsif (defined $self->{ylab})
	{
		$self->{tw} += $textH + $SBV::conf->{hspace}*2;	
		$self->{ox} -= $textH + $SBV::conf->{hspace}*2;
		$self->{ylab} = undef;
	}
}

sub xlim
{
	my ($self,@vals) = @_;
	return $self->{xlim} unless (@vals);
	
	unless ($self->{xlim})
	{
		$self->{xlim} = \@vals;
		return;
	}

	my @raw = @{$self->{xlim}};
	my ($rawmin,$rawmax) = @raw[0,1];
	my ($newmin,$newmax) = @vals[0,1];
	$raw[0] = min[$rawmin,$newmin];
	$raw[1] = max[$rawmax,$newmax];
	$self->{xlim} = \@raw;
}

sub setXlim
{
	my ($self,@vals) = @_;
	$self->{conf}->{xlim} = join " " , @vals;
}

sub setYlim
{
	my ($self,@vals) = @_;
	$self->{conf}->{ylim} = join " " , @vals;
}

sub ylim
{
	my ($self,@vals,%opts) = @_;
	return $self->{ylim} unless (@vals);
	unless ($self->{ylim})
	{
		$self->{ylim} = \@vals;
		return;
	}
	
	my @raw = @{$self->{ylim}}; 
	my ($rawmin,$rawmax) = @raw[0,1];
	my ($newmin,$newmax) = @vals[0,1];
	
	$self->{ylim} = [min([$rawmin,$newmin]),max([$rawmax,$newmax])];
}

sub xaxis
{
	my ($self) = @_;
	
	my $xlim = $self->{xlim};
	my $tick;
	if (scalar @$xlim == 3)
	{
		$tick = join " " , @$xlim;	
	}
	else
	{
		$tick = dividing($xlim);	
	}
	my %par = (tick=>$tick);
	
	if ($self->{xnames})
	{
		$par{translate} = 0.5;	
		$par{ticktext} = $self->{ticktext};
		$par{show_tick_line} = 0;
		$par{start} = 0;
	}
	
	if ($self->{conf}->{xaxis})
	{
		foreach my$key(keys %{$self->{conf}->{xaxis}})
		{
			$par{$key} = $self->{conf}->{xaxis}->{$key};
		}
	}
	
	my $axis = SBV::STONE::AXIS->new(%par,parent=>$self->{parent});
	my $thick = $axis->thickness;

	$self->{th} -= $thick;
	$self->{oy} -= $thick;
	$self->{xaxis} = $axis;
}

sub yaxis
{
	my ($self) = @_;
	
	my $ylim = $self->{ylim};
	my $tick;
	if (scalar @$ylim == 3)
	{
		$tick = join " " , @$ylim;	
	}
	else
	{
		$tick = dividing($ylim);	
	}	

	my %par = (tick=>$tick,angle=>-90,side=>"left");
	if ($self->{conf}->{yaxis})
	{
		foreach my$key(keys %{$self->{conf}->{yaxis}})
		{
			$par{$key} = $self->{conf}->{yaxis}->{$key};
		}
	}
	my $axis = SBV::STONE::AXIS->new(%par,parent=>$self->{parent});
	my $thick = $axis->thickness;

	$self->{tw} -= $thick;
	$self->{ox} += $thick;
	$self->{yaxis} = $axis;
}

sub flip
{
	my $self = shift;
	($self->{yaxis},$self->{xaxis}) = ($self->{xaxis},$self->{yaxis});
	my $xlab = $self->{xlab};
	my $ylab = $self->{ylab};
	$self->xlab($ylab);
	$self->ylab($xlab);
	
	$self->{ox} = $self->{ox} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};
	$self->{tw} = $self->{tw} - $self->{yaxis}->{thickness} + $self->{xaxis}->{thickness};
	$self->{oy} = $self->{oy} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};
	$self->{th} = $self->{th} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};

	$self->{xaxis}->aes(angle=>0,side=>'right');
	$self->{yaxis}->aes(angle=>-90,side=>'left');

	return 1;
}

# draw the side of the ggplot2
sub draw
{
	my $self = shift;
	$self->check_features;
	
	# init legend
	my $legend;
	if ($self->{conf}->{legend})
	{
		my $lconf = SBV::CONF::fetch_first_conf('legend',$self->{conf});
		my $legend_par = $self->legend;
		$legend = SBV::STONE::LEGEND->new(conf=>$lconf,%$legend_par);
		if ($lconf->{pos} eq "outright")
		{
			my $legend_width = $legend->width;
			$self->{tw} -= $legend_width;
		}
	}
	
	# reset xlim and ylim 
	if ($self->{conf}->{xlim})
	{
		my @tmp = split /[\s\,\t]+/ , $self->{conf}->{xlim};
		$self->{xlim} = \@tmp;
	}

	if ($self->{conf}->{ylim})
	{
		my @tmp = split /[\s\,\t]+/ , $self->{conf}->{ylim};
		$self->{ylim} = \@tmp;
	}

	# init axis
	$self->xaxis;
	$self->yaxis;
	$self->flip if ($self->{conf}->{flip});
	
	my ($xaxis,$yaxis) = ($self->{xaxis},$self->{yaxis});
	$xaxis->aes(ox=>$self->{ox},oy=>$self->{oy},length=>$self->{tw},bgline=>$self->{th});
	$yaxis->aes(ox=>$self->{ox},oy=>$self->{oy},length=>$self->{th},bgline=>$self->{tw});
	
	# background
	my $conf = {ox=>$self->{ox},oty=>$self->{oy}-$self->{th},
		tw=>$self->{tw},th=>$self->{th},
		border=>$self->{conf}->{border},
		background=>$self->{conf}->{background}
	};
	SBV::DRAW::background($conf,$self->{parent});
	
	# draw axis
	$xaxis->plot;
	$yaxis->plot;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	my $font = SBV::Font->fetch_font('CLASSsubtitle');
	my $textH = $font->fetch_text_height;
	
	if ($self->{xlab})
	{
		my $textW = $font->fetch_text_width($self->{xlab});
		my $x = $self->{ox} + $self->{tw}/2 - $textW/2;
		my $y = $self->{conf}->{oy} - $vi;
		$self->{parent}->text(x=>$x,y=>$y,class=>"subtitle")->cdata($self->{xlab});
	}

	if ($self->{ylab})
	{
		my $textW = $font->fetch_text_width($self->{ylab});
		my $x = $self->{conf}->{ox} + $vi + $textH;
		my $y = $self->{oy} - $self->{th}/2 + $textW/2;
		$self->{parent}->text(class=>"subtitle",x=>$x,y=>$y,transform=>"rotate(-90,$x,$y)")->cdata($self->{ylab});
	}

	$font = SBV::Font->fetch_font('CLASStitle');
	$textH = $font->fetch_text_height;
	if ($self->{title})
	{
		my $textW = $font->fetch_text_width($self->{title});
		my $x = $self->{ox} + $self->{tw}/2 - $textW/2;
		my $y = $self->{conf}->{oty} + $vi + $textH;
		$self->{parent}->text(x=>$x,y=>$y,class=>"title")->cdata($self->{title});
	}
	
	foreach (@{$self->{eval}})
	{
		my $cmd =  "\$self->$_";
		my $temp = eval("$cmd");
		ERROR('ggplot2_eval_err',$_) if (! defined $temp);
	}

	if ($legend)
	{
		$legend->location($self);
		$legend->draw($self->{parent});
	}
	
}

# set the legend 
sub legend
{
	my $self = shift;
	my $legend = $self->{legend};

	if (@_)
	{
		my %par = @_;
		$legend->{$_} = $par{$_} foreach (keys %par);
	}
	else
	{
		return $legend;
	}

	return 1;
}

# aes
# change the paramter for this class
# like aes of ggplot2 in R
sub aes
{
	my $self = shift;
	my %param = @_;

	if ($param{conf})
	{
		$self->load_conf($param{conf});
	}
	
	foreach my$key (keys %param)
	{
		if ($key eq "xlab")
		{
			$self->xlab($param{$key});
		}
		elsif ($key eq "ylab")
		{
			$self->ylab($param{$key});
			
		}
		elsif ($key eq "title")
		{
			$self->title($param{$key});
		}
		elsif ($key eq "file")
		{
			$self->read($param{file});	
		}
		else
		{
			$self->{$key} = $param{$key};
		}
	}
}

*features = \&aes;

# load the ggplot2 conf for RECT OS
sub load_conf
{
	my ($self,$conf) = @_;	
	
	$self->{ox} = $conf->{ox} or die;
	$self->{oy} = $conf->{oy} or die;
	$self->{tw} = $conf->{tw} or die;
	$self->{th} = $conf->{th} or die;
	$self->{oty} = $conf->{oty} or die;
	
	$self->{stat} = $conf->{stat};

	my @items = ("xlab","ylab","title","xnames");
	foreach my$item (@items)
	{
		next unless (defined $conf->{$item});

		if ($item eq "xlab") 
		{
			$self->xlab($conf->{$item});
		}
		elsif ($item eq "ylab")
		{
			$self->ylab($conf->{$item});	
		}
		elsif ($item eq "title")
		{
			$self->title($conf->{$item});
		}
		else
		{
			$self->{$item} = $conf->{$item};
		}
	}
	
	@items = ("fill","col","shape","type");
	foreach my$item(@items)
	{
		if ($conf->{$item})
		{
			my @temp = SBV::CONF::fetch_val($conf,$item);
			if ($item eq "col" || $item eq "fill")
			{
				@temp = map { SBV::Colors::fetch_color($_) } @temp;
				$self->{$item} = \@temp;
			}
			else
			{
				$self->{$item} = \@temp;
			}
		}
	}

	$self->{oty} = $self->{oy} - $self->{th};
}

# Name: localPar
# Func: init the local parameter
sub localPar
{
	my $self = shift;
	my $param = shift;
	my $factor = shift || 0;
	my $level;
	
	foreach my$key (keys %$self)
	{
		$param->{$key} = $self->{$key} if (! defined $param->{$key});	
	}
	
	#if ($param->{file})
	#{
	#	$self->read($param->{file});	
	#}
	
	my @labels;
	if ($param->{group})
	{
		if (! defined $param->{level})
		{
			$param->{level} = levels($param->{data}->{col}->{$param->{group}});
			@labels = uniq_arr ($param->{data}->{col}->{$param->{group}});
		}
	}

	if ($param->{col})
	{
		if (exists $param->{data}->{col}->{$param->{col}})
		{
			$param->{col} = _arr2color($param->{data}->{col}->{$param->{col}},1);
			if (! defined $param->{level})
			{
				$param->{level} = levels($param->{data}->{col}->{$param->{col}});
				@labels = uniq_arr($param->{data}->{col}->{$param->{col}});
			}
		}
		elsif (ref $param->{col} eq "ARRAY")
		{
			my @colors = @{$param->{col}};
			@colors = map {SBV::Colors::fetch_color($_)} @colors;
			$param->{col} = \@colors;
		}
		else
		{
			my @colors = split /\s+/ , $param->{col};
			@colors = map {SBV::Colors::fetch_color($_)} @colors;
			$param->{col} = \@colors;
		}
	}
	
	if ($param->{fill})
	{
		if (exists $param->{data}->{col}->{$param->{fill}})
		{
			my $fill = $param->{data}->{col}->{$param->{fill}};
			$param->{fill} = _arr2color($fill,1);	
			if (! defined $param->{level})
			{
				$param->{level} = levels($fill);
				@labels = uniq_arr($fill);
			}
		}
		elsif (ref $param->{fill} eq "ARRAY")
		{
			my @fill = @{$param->{fill}};
			@fill = map {SBV::Colors::fetch_color($_)} @fill;
			$param->{fill} = \@fill;
		}
		else
		{
			my @fill = split /\s+/ , $param->{fill};
			@fill = map {SBV::Colors::fetch_color($_)} @fill;
			$param->{fill} = \@fill;
		}
	}
	
	if (! exists $param->{level})
	{
		my @rownames = $param->{data}->rownames;
		my @temp = map { 0 } 0 .. $#rownames;
		$param->{level} = \@temp;
		@labels = ('label');
	}
	
	$self->legend(label=>\@labels) if (! exists $self->{legend}->{label});
	return $param;
}

sub _arr2color
{
	my$arr = shift;
	my$factor = shift;
	
	if ($factor)
	{
		my @temp = uniq_arr($arr);
		$arr = \@temp;
	}
	
	my $isColor = SBV::Colors::isColor(@$arr);
	my @colors;
	if ($isColor)
	{
		@colors = map {SBV::Colors::fetch_color($_)} @$arr;
	}
	else
	{
		@colors = SBV::Colors::rainbow($#$arr+1);
	}
	
	return \@colors;
}

# get the svg location
sub coord2pos
{
	my $self = shift;
	my $x = shift;
	my $y = shift;

	my $newx = $self->{ox} + $self->{xaxis}->fetch_dis($x);
	my $newy = $self->{oy} - $self->{yaxis}->fetch_dis($y);
	
	return ($newx,$newy);
}

sub xcoord2pos
{
	my $self = shift;
	my $x = shift;
	return $self->{ox} + $self->{xaxis}->fetch_dis($x);
}

sub ycoord2pos
{
	my $self = shift;
	my $y = shift;
	return $self->{oy} - $self->{yaxis}->fetch_dis($y);
}

# get the svg true distance of two points
sub coord2dis
{
	my $self = shift;
	my ($x1,$y1,$x2,$y2) = @_;
	
	my ($newx1,$newy1) = $self->coord2pos($x1,$y1);
	my ($newx2,$newy2) = $self->coord2pos($x2,$y2);

	my $dis = sqrt ( ($newx1-$newx2)**2 + ($newy1-$newy2)**2 );
	return $dis;
}

# density
sub density
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newdata,$xval,$names) = $self->doInitAes_density(\%param);
	unless ($param{draw})
	{
		push @{$self->{eval}} , "density($opts)";
		return 1;
	}

	my @xval = @$xval;
	my @names = @$names;

	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $parent = $par->{parent};
	my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;

	my ($xcor,$ycor);
	
	foreach my$i( 0 .. $#names )
	{
		my $x = $xval[$i];
		my $y = $newdata->{$names[$i]};
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @$xcor , $rectx;
		push @$ycor , $recty;
	}
	
	my $style = "stroke:$col->[0];stroke-width:$stroke_width;fill:none;";
	$style .= "stroke-dasharray:$par->{stroke_dashes}" if ($par->{stroke_dashes});

	my $points = $parent->get_path(x=>$xcor,y=>$ycor,-type=>'polyline');
	$parent->polyline(%$points,style=>$style);
}

# multi group bar
sub mbar
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);
	my ($par,$newdata,$xval,$names) = $self->doInitAes_bar_group(\%param);
	my @xval = @$xval;
	my @names = @$names;
	
	# data stat method the draw bar
	my $stat = $par->{'stat'} || "mean";

	my $col = $par->{col} || ["none"];
	my $fill = $par->{fill} || ["#000"];
	my $parent = $par->{parent};
	my $width = $par->{width} || 0.8;
	my $size = $par->{size} || 1;
	my $swidth = $par->{stroke_width} || 0;
	
	# set the legend
	my $factor = $par->{factor};
	$self->legend(shape=>[0],color=>$col,fill=>$fill,label=>$factor);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "mbar($opts)";
		return 1;
	}
	
	# fetch the xaxis and yaxis info 
	my $xaxis = $self->{xaxis};
	my $xmin = $xaxis->{min};
	my $xmax = $xaxis->{max};
	my $yaxis = $self->{yaxis};
	my $ymin = $yaxis->{min};
	my $ymax = $yaxis->{max};
	
	my $vi = $SBV::conf->{vspace};
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font();
	my $textH = $font->fetch_text_height;
	
	# get the bar width 
	my $barW = $self->{conf}->{flip} ? $yaxis->{unit} * $width : $xaxis->{unit} * $width;
	
	if ($par->{pileup}) # pile up the group bar
	{
		foreach my$i( 0 .. $#names )
		{
			my $x = $xval[$i];
			my $name = $names[$i];
			my $subdata = $newdata->{$name};
			
			my $minusy1 = 0;
			my $plusy1 = 0;
			foreach my$j (0 .. $#$factor)
			{
				my $group = $factor->[$j];
				next if (! exists $subdata->{$group});
				my @val = @{$subdata->{$group}};
				my $val =  fetch_y($stat,\@val);
				
				my $color = loop_arr($col,$j);
				my $fill_col = loop_arr($fill,$j);
				
				if ($val < 0)
				{
					my $y2 = $minusy1 + $val;
					if ($self->{conf}->{flip})
					{
						my $h = $xaxis->fetch_dis($minusy1) - $xaxis->fetch_dis($y2);
						my ($rectx,$recty) = $self->coord2pos($y2,$x+$width/2);
						$parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
							style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
					}
					else
					{
						my $h = $yaxis->fetch_dis($minusy1) - $yaxis->fetch_dis($y2);
						my ($rectx,$recty) = $self->coord2pos($x-$width/2 , $minusy1);
						$parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
							style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
					}
					$minusy1 = $y2;
				}
				else
				{
					my $y2 = $plusy1 + $val;
					if ($self->{conf}->{flip})
					{
						my $h = $xaxis->fetch_dis($y2) - $xaxis->fetch_dis($plusy1);
						my ($rectx,$recty) = $self->coord2pos($plusy1 , $x+$width/2);

						if ($par->{letter})
						{
							my $letter = $par->{letter}->[$j];
							SBV::DRAW::fixText($rectx,$recty,$h,$barW,$letter,"fill:$fill_col","freq",$parent);
						}
						else
						{
							$parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
								style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
						}
					}
					else
					{
						my $h = $yaxis->fetch_dis($y2) - $yaxis->fetch_dis($plusy1);
						my ($rectx,$recty) = $self->coord2pos($x-$width/2 , $y2);

						if ($par->{letter})
						{
							my $letter = $par->{letter}->[$j];
							SBV::DRAW::fixText($rectx,$recty,$barW,$h,$letter,"fill:$fill_col","freq",$parent);
						}
						else
						{
							$parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
								style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
						}
					}
					$plusy1 = $y2;
				}
			}
		}
	}
	else # draw group bar separately
	{
		# get the width of each bar
		my $groupN = scalar @$factor;
		$barW = $barW/$groupN;
		my $tempW = $barW * $size;

		foreach my$i( 0 .. $#names )
		{
			my $x = $xval[$i];
			my $name = $names[$i];
			my $subdata = $newdata->{$name};

			foreach my$j (0 .. $#$factor)
			{
				my $group = $factor->[$j];
				next if (! exists $subdata->{$group});

				my @val = @{$subdata->{$group}};
				my $y = fetch_y($stat,\@val);
				$y = nearest 0.01 , $y;

				my $color = loop_arr($col,$j);
				my $fill_col = loop_arr($fill,$j);
				
				if ($self->{conf}->{flip})
				{
					my ($rectx,$recty,$h,$textx);
					my $fontW = $font->fetch_text_width($y);
					
					if ($xmax <= 0)
					{
						$h = $xaxis->fetch_dis($xmax) - $xaxis->fetch_dis($y);
						($rectx,$recty) = $self->coord2pos($y,$x+$width/2 - $j*$width/$groupN);
						$textx = $rectx - $hi - $fontW;
					}
					elsif ($xmin >= 0)
					{
						$h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis($xmin);
						($rectx,$recty) = $self->coord2pos($xmin,$x+$width/2 - $j*$width/$groupN);
						$textx = $rectx + $h + $hi;
					}
					else
					{
						if ($y > 0)
						{
							$h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis(0);
							($rectx,$recty) = $self->coord2pos(0,$x+$width/2 - $j*$width/$groupN);
							$textx = $rectx + $h + $hi;
						}
						else
						{
							$h = $xaxis->fetch_dis(0) - $xaxis->fetch_dis($y);
							($rectx,$recty) = $self->coord2pos($y,$x+$width/2 - $j*$width/$groupN);
							$textx = $rectx - $hi - $fontW;
						}
					}
					
					$recty += $barW * (1-$size)/2;
					$parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$tempW,
							style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

					# add the val to the bar top
					if ($par->{val})
					{
						my $texty = $self->ycoord2pos($x+$width/2-($j+0.5)*$width/$groupN) + $textH/2;
						$parent->text(x=>$textx,y=>$texty)->cdata($y);
					}
				}
				else
				{
					my ($rectx,$recty,$h,$texty);
					if ($ymax <= 0)
					{
						$h = $yaxis->fetch_dis($ymax) - $yaxis->fetch_dis($y);
						($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
						$texty = $recty + $h + $vi + $textH;
					}
					elsif ($ymin >= 0)
					{
						$h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis($ymin);
						($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
						$texty = $recty - $vi;
					}
					else
					{
						if ($y > 0)
						{
							$h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis(0);
							($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
							$texty = $recty - $vi;
						}
						else
						{
							$h = $yaxis->fetch_dis(0) - $yaxis->fetch_dis($y);
							($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,0);
							$texty = $recty + $h + $vi + $textH;
						}	
					}
					$rectx += $barW * (1-$size)/2;
					$parent->rect(x=>$rectx,y=>$recty,width=>$tempW,height=>$h,
							style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

					# add the val to the bar top
					if ($par->{val})
					{
						my $fontW = $font->fetch_text_width($y);
						my $textx = $self->xcoord2pos($x-$width/2+($j+0.5)*$width/$groupN) - $fontW/2;
						$parent->text(x=>$textx,y=>$texty)->cdata($y);
					}
				}
				
			}
		}
	}
}

# draw bar
*histogram = \&bar;
*hist = \&bar;

sub bar
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	if (exists $param{group})
	{
		$self->mbar(%param);
		return 1;
	}

	my ($par,$newdata,$xval,$names) = $self->doInitAes_bar(\%param);
	my @xval = @$xval;
	my @names = @$names;

	# data stat method the draw bar 
	# mean, max, min
	my $stat = $par->{'stat'} || "mean";
	
	# default fill and col
	my $col = $par->{col} || ["none"];
	my $fill = $par->{fill} || ["#000"];
	my $parent = $par->{parent};
	my $width = $par->{width} || 0.6;
	my $swidth = $par->{stroke_width} || 0;

	# set the legend 
	$self->legend(shape=>[0],color=>$col,fill=>$fill,label=>\@names);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "bar($opts)";
		return 1;
	}
	
	# fetch the xaxis info 
	my $yaxis = $self->{yaxis};
	my $ymin = $yaxis->{min};
	my $ymax = $yaxis->{max};
	
	# for filp , fetch the yaxis info
	my $xaxis = $self->{xaxis};
	my $xmin = $xaxis->{min};
	my $xmax = $xaxis->{max};
	
	# get the bar width 
	my $barW = $self->{conf}->{flip} ? $yaxis->{unit} * $width : $xaxis->{unit} * $width;
	
	# fetch the font info for value marker
	my $font = SBV::Font->fetch_font();
	my $textH = $font->fetch_text_height;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	foreach my$i( 0 .. $#names )
	{
		my $x = $xval[$i];
		my $name = $names[$i];
		
		my @val = @{$newdata->{$name}};
		my $y = fetch_y($stat,\@val); # the value 
		$y = nearest 0.01 , $y;
		my $color = loop_arr($col,$i);
		my $fill_col = loop_arr($fill,$i);
		
		if ($self->{conf}->{flip})
		{
			my ($rectx,$recty,$h,$textx);
			if ($xmax <= 0) # values are all negative 
			{
				$h = $xaxis->fetch_dis($xmax) - $xaxis->fetch_dis($y);
				($rectx,$recty) = $self->coord2pos($y,$x+$width/2);
				$textx = $rectx - $hi - $font->fetch_text_width($y);
			}
			elsif ($xmin >= 0) # values are all positive
			{
				$h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis($xmin);
				($rectx,$recty) = $self->coord2pos($xmin,$x+$width/2);
				$textx = $rectx + $h + $hi;
			}
			else
			{
				if ($y > 0)
				{
					$h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis(0);
					($rectx,$recty) = $self->coord2pos(0,$x+$width/2);
					$textx = $rectx + $h + $hi;
				}
				else
				{
					$h = $xaxis->fetch_dis(0) - $xaxis->fetch_dis($y);
					($rectx,$recty) = $self->coord2pos($y,$x+$width/2);
					$textx = $rectx - $hi - $font->fetch_text_width($y);
				}
			}
			
			$parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
				style=>{fill=>$fill_col,stroke=>$color,'stroke_width'=>$swidth});
			
			# add the val to the bar top
			if ($par->{val})
			{
				my $texty = $self->ycoord2pos($x) + $textH/2;
				$parent->text(x=>$textx,y=>$texty)->cdata($y);
			}
		}
		else
		{
			my ($rectx,$recty,$h,$texty);
			if ($ymax <= 0) # values are all negative
			{
				$h = $yaxis->fetch_dis($ymax) - $yaxis->fetch_dis($y);
				($rectx,$recty) = $self->coord2pos($x-$width/2,$ymax);
				$texty = $recty + $h + $vi + $textH;
			}
			elsif ($ymin >= 0) # values are all positive
			{
				$h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis($ymin);
				($rectx,$recty) = $self->coord2pos($x-$width/2,$y);
				$texty = $recty - $vi;
			}
			else
			{
				if ($y > 0)
				{
					$h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis(0);
					($rectx,$recty) = $self->coord2pos($x-$width/2,$y);
					$texty = $recty - $vi;
				}
				else
				{
					$h = $yaxis->fetch_dis(0) - $yaxis->fetch_dis($y);
					($rectx,$recty) = $self->coord2pos($x-$width/2,0);
					$texty = $recty + $h + $vi + $textH;
				}
			}

			$parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
					style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

			# add the val to the bar top
			if ($par->{val})
			{
				my $textW = $font->fetch_text_width($y);
				my $textx = $self->xcoord2pos($x) - $textW/2;
				$parent->text(x=>$textx,y=>$texty)->cdata($y);
			}
		}
	}
}

# fetch y coordinate of bar by stat
sub fetch_y
{
	my $stat = shift;
	my $array = shift;

	if ($stat eq "max")
	{
		return max($array);	
	}
	elsif ($stat eq "min")
	{
		return min($array);
	}
	elsif($stat eq "mean")
	{
		return mean($array);
	}
}

# draw points
sub points
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);
	my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @yval = @$yval;
	
	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $shape = exists $par->{shape} ? $par->{shape} : [1];
	my $conf = $par->{conf} || {};
	my $parent = $par->{parent};
	my $level = $par->{level};
	my $swidth = $par->{stroke_width} || 0;
	
	my $size = $par->{size} || 5;
	$conf->{symbol_width} = $size * 2;
	$conf->{symbol_height} = $size * 2;

	# init the symbol 
	my @levels = uniq_arr($level);
	my @symid = map {
		my $pch = loop_arr($shape,$_);
		my $fill_col = loop_arr($fill,$_);
		my $color = loop_arr($col,$_);
		SBV::STONE::SYMBOL::new($pch,fill=>$fill_col,color=>$color,stroke_width=>$swidth);
	} 0 .. $#levels;
	
	# set the legend 
	$self->legend(shape=>$shape,color=>$col,fill=>$fill,stroke_width=>$swidth);	
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "points($opts)";
		return 1;
	}

	my ($xcor,$ycor,$symids);
	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $yval[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @$xcor , $rectx;
		push @$ycor , $recty;
		push @$symids , $symid[$level->[$i]];
	}
	
	SBV::DRAW::points($xcor,$ycor,$symids,$conf,$parent);
}

*scatter = \&points;

# honrizontal lines
sub hline
{
	my $self = shift;
	my ($yintercept,%param) = @_;

	unless ($param{draw})
	{
		my $opts = restore_cmd($yintercept) . "," . restore_cmd(\%param);
		push @{$self->{eval}} , "hline($opts)";
		return 1;
	}

	my $parent = $param{parent} || $self->{parent};
	my $style = fetch_line_style(%param);
	
	my $xmin = $self->{xaxis}->{min};
	my $xmax = $self->{xaxis}->{max};
	my $ymin = $self->{yaxis}->{min};
	my $ymax = $self->{yaxis}->{max};

	my $x1 = $self->xcoord2pos($xmin); 
	my $x2 = $self->xcoord2pos($xmax);
	$x1 -= $self->{xaxis}->{start} * $self->{xaxis}->{unit} * $self->{xaxis}->{window};

	my %par = (x1=>$x1,x2=>$x2);
	$par{style} = $style;

	if (ref $yintercept eq "ARRAY")
	{
		foreach my$num (@$yintercept)	
		{
			if ($num > $ymax || $num < $ymin)
			{
				WARN("the hline is in the outside of the axis");
				next;
			}
			
			my $y = $self->ycoord2pos($num);
			$parent->line(y1=>$y,y2=>$y,%par);
		}
	}
	else
	{
		if ($yintercept > $ymax || $yintercept < $ymin)
		{
			WARN("the hline is in the outside of the axis"); 
			next;		
		}
		
		my $y = $self->ycoord2pos($yintercept);
		$parent->line(y1=>$y,y2=>$y,%par);
	}

	return 1;
}

# vertical lines
sub vline
{
	my $self = shift;
	my ($xintercept,%param) = @_;
	
	unless ($param{draw})
	{
		my $opts = restore_cmd($xintercept) . "," . restore_cmd(\%param);
		push @{$self->{eval}} , "vline($opts)";
		return 1;
	}

	my $parent = $param{parent} || $self->{parent};
	my $style = fetch_line_style(%param);
	
	my $xmin = $self->{xaxis}->{min};
	my $xmax = $self->{xaxis}->{max};
	my $ymin = $self->{yaxis}->{min};
	my $ymax = $self->{yaxis}->{max};
	my $y1 = $self->ycoord2pos($ymin); 
	my $y2 = $self->ycoord2pos($ymax);
	$y1 += $self->{yaxis}->{start} * $self->{yaxis}->{window} * $self->{yaxis}->{unit};

	my %par = (y1=>$y1,y2=>$y2);
	$par{style} = $style;

	if (ref $xintercept eq "ARRAY")
	{
		foreach my$num (@$xintercept)	
		{
			if ($num > $xmax || $num < $xmin)
			{
				WARN("the vline is in the outside of the axis");
			}
			else
			{
				my $x = $self->xcoord2pos($num);
				$parent->line(x1=>$x,x2=>$x,%par);
			}
		}
	}
	else
	{
		if ($xintercept > $xmax || $xintercept < $xmin)
		{
			WARN("the vline is in the outside of the axis");
			next;
		}
		else
		{
			my $x = $self->xcoord2pos($xintercept);
			$parent->line(x1=>$x,x2=>$x,%par);
		}
	}

	return 1;
}

# abline
sub abline
{
	my $self = shift;
	my ($k,$b,%param) = @_;
	
	unless ($param{draw})
	{
		my $opts = restore_cmd(\%param);
		push @{$self->{eval}} , "abline($k,$b,$opts)";
		return 1;
	}

	my $parent = $param{parent} || $self->{parent};
	my $style = fetch_line_style(%param);

	if (0 == $k)
	{
		$self->hline($b,%param);
	}
	else
	{
		my $xmin = $self->{xaxis}->{min};
		my $xmax = $self->{xaxis}->{max};
		my $ymin = $self->{yaxis}->{min};
		my $ymax = $self->{yaxis}->{max};
	
		my %par;
		my $flag = 0;
		
		# x = xmin => y = k*xmin + b
		my $temp = $k*$xmin + $b;
		if ($temp >= $ymin && $temp <= $ymax)
		{
			$par{x1} = $xmin;
			$par{y1} = $temp;
			$flag = 1;
		}

		# x = xmax => y = k*xmax + b
		$temp = $k*$xmax + $b;
		if ($temp >= $ymin && $temp <= $ymax)
		{
			if (1 == $flag)
			{
				$par{x2} = $xmax;
				$par{y2} = $temp;
				$flag = 2;
			}
			else
			{
				$par{x1} = $xmax;
				$par{y1} = $temp;
				$flag = 1;
			}
		}

		# y = ymin => x = (ymin-b)/k
		if (2 != $flag)
		{
			$temp = ($ymin-$b)/$k;
			if ($temp >= $xmin && $temp <= $xmax)
			{
				if (0 == $flag)
				{
					$par{x1} = $temp;
					$par{y1} = $ymin;
					$flag = 1;
				}
				elsif (1 == $flag)
				{
					$par{x2} = $temp;
					$par{y2} = $ymin;
					$flag = 2;
				}
			}
		}

		# y = ymax => x = (ymax-b)/k
		if (2 != $flag)
		{
			$temp = ($ymax-$b)/$k;	
			if ($temp >= $xmin && $temp <= $xmax)
			{
				if (0 == $flag)
				{
					$par{x1} = $temp;
					$par{y1} = $ymax;
					$flag = 1;
				}
				elsif (1 == $flag)
				{
					$par{x2} = $temp;
					$par{y2} = $ymax;
					$flag = 2;
				}
			}
		}
		
		if (2 != $flag)
		{
			WARN("the abline is in the outside of the axis!");	
			return;
		}
		
		$par{x1} = $self->xcoord2pos($par{x1});
		$par{x2} = $self->xcoord2pos($par{x2});
		$par{y1} = $self->ycoord2pos($par{y1});
		$par{y2} = $self->ycoord2pos($par{y2});
		$par{style} = $style;

		$parent->line(%par);
	}
	
	return 1;
}

# linerange
sub linerange
{
	my $self = shift;
	my %param = @_;
	$self->range("linerange",%param);
}

# pointrange
sub pointrange
{
	my $self = shift;
	my %param = @_;
	$self->range("pointrange",%param);
}

# crossbar
sub crossbar
{
	my $self = shift;
	my %param = @_;
	$self->range("crossbar",%param);
}

# errbar
sub errbar
{
	my $self = shift;
	my %param = @_;
	$self->range("errbar",%param);
}

# multi group range
sub mrange
{
	my ($self,$type,%param) = @_;
	my $opts = restore_cmd(\%param);
	
	my ($par,$newdata,$xval,$names) = $self->doInitAes_group(\%param);
	my @xval = @$xval;
	my @names = @$names;

	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $width = $par->{width} || 0.8;
	my $size = $par->{size} || 1;
	my $stat = $par->{stat} || "sem";
	my $parent = $par->{parent};
	my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;
	my $shape = fetch_range_shape($type);
	my $factor = $par->{factor};
	
	$self->legend(color=>$col,fill=>$fill,label=>$factor,shape=>[$shape]) if (1 == $par->{legend});

	unless ($param{draw})
	{
		push @{$self->{eval}} , "mrange(\'$type\',$opts)";
		return 1;
	}
	
	my $xaxis = $self->{xaxis};
	my $yaxis = $self->{yaxis};

	my $groupN = scalar @$factor;
	my $barW = $width/$groupN;
	foreach my$i( 0 .. $#names )
	{
		my $name = $names[$i];
		my $x = $xval[$i];
		my $subdata = $newdata->{$name};

		foreach my$j (0 .. $#$factor)
		{
			my $group = $factor->[$j];
			my $color = loop_arr($col,$j);
			my $fill_col = loop_arr($fill,$j);

			my @val = @{$subdata->{$group}};
			my ($mid,$up,$low);
			
			my $style = "stroke:$color;stroke-width:$stroke_width";

			if ($stat eq "sem")
			{
				my $mean = mean(\@val);
				my $sem = sem(\@val);
				$mid = $mean;
				$up = $mean+$sem;
				$low = $mean-$sem;
			}
			elsif ($stat eq "normal")
			{
				my $max = max(\@val);
				my $min = min(\@val);
				my $mean = mean(\@val);
				$mid = $mean;
				$up = $max;
				$low = $min;
			}

			my $y1 = $self->{oy} - $yaxis->fetch_dis($up);	
			my $y2 = $self->{oy} - $yaxis->fetch_dis($mid);	
			my $y3 = $self->{oy} - $yaxis->fetch_dis($low);

			my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
			my $x2 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW);
			my $x3 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );

			if ($type eq "errbar")
			{
				$parent->line(x1=>$x1,y1=>$y1,x2=>$x3,y2=>$y1,style=>$style,class=>"errbar");
				$parent->line(x1=>$x1,y1=>$y3,x2=>$x3,y2=>$y3,style=>$style,class=>"errbar");
				$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"errbar");
			}
			elsif ($type eq "linerange")
			{
				$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"linerange");
			}
			elsif ($type eq "pointrange")
			{
				my $r = $stroke_width * 2; 
				$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"pointrange");	
				$parent->circle(cx=>$x2,cy=>$y2,r=>$r,style=>"fill:$color;'stroke-width':0");
			}
			elsif ($type eq "crossbar")
			{
				$parent->rect(x=>$x1,y=>$y1,width=>$x3-$x1,height=>$y3-$y1,
						style=>{stroke=>$color,'stroke-width'=>1,fill=>$fill_col},class=>"crossbar");
				$parent->line(x1=>$x1,x2=>$x3,y1=>$y2,y2=>$y2,
						style=>$style,class=>"crossbar");
			}
		}
	}

	return 1;
}


sub range
{
	my ($self,$type,%param) = @_;
	my $opts = restore_cmd(\%param);

	if (exists $param{group})
	{
		$self->mrange($type,%param);
		return 1;
	}

	my ($par,$newdata,$xvalue,$names) = $self->doInitAes(\%param);
	my @xval = @$xvalue;
	my @names = @$names;
	
	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $width = $par->{width} || 0.6;
	my $stat = $par->{stat} || "sem";
	my $parent = $par->{parent};
	my $stroke_width = $par->{stroke_width} || 2;
	my $shape = fetch_range_shape($type);
	$self->legend(color=>$col,fill=>$fill,label=>\@names,shape=>[$shape]) if ($par->{legend});
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "range(\"$type\",$opts)";
		return 1;
	}

	my $xaxis = $self->{xaxis};
	my $yaxis = $self->{yaxis};

	foreach my$i( 0 .. $#names )
	{
		my $name = $names[$i];
		my $x = $xval[$i];
		my $color = loop_arr($col,$i);
		my $fill_col = loop_arr($fill,$i);
		
		my @val = @{$newdata->{$name}};
		
		my ($mid,$up,$low);
		
		if ($stat eq "sem")
		{
			my $mean = mean(\@val);
			my $sem = sem(\@val);
			$mid = $mean;
			$up = $mean+$sem;
			$low = $mean-$sem;
		}
		elsif ($stat eq "normal")
		{
			my $max = max(\@val);
			my $min = min(\@val);
			my $mean = mean(\@val);
			$mid = $mean;
			$up = $max;
			$low = $min;
		}

		my $y1 = $self->{oy} - $yaxis->fetch_dis($up);	
		my $y2 = $self->{oy} - $yaxis->fetch_dis($mid);	
		my $y3 = $self->{oy} - $yaxis->fetch_dis($low);
		
		my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2);
		my $x2 = $self->{ox} + $xaxis->fetch_dis($x);
		my $x3 = $self->{ox} + $xaxis->fetch_dis($x+$width/2);
		
		my $style = "stroke:$color;stroke-width:$stroke_width";

		if ($type eq "errbar")
		{
			$parent->line(x1=>$x1,y1=>$y1,x2=>$x3,y2=>$y1,style=>$style,class=>"errbar");
			$parent->line(x1=>$x1,y1=>$y3,x2=>$x3,y2=>$y3,style=>$style,class=>"errbar");
			$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"errbar");
		}
		elsif ($type eq "linerange")
		{
			$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"linerange");
		}
		elsif ($type eq "pointrange")
		{
			my $r = $stroke_width * 2; 
			$parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"pointrange");	
			$parent->circle(cx=>$x2,cy=>$y2,r=>$r,style=>"fill:$color;stroke-width:0");
		}
		elsif ($type eq "crossbar")
		{
			$parent->rect(x=>$x1,y=>$y1,width=>$x3-$x1,height=>$y3-$y1,
				style=>"stroke:$color;'stroke-width':1;fill:$fill_col",class=>"crossbar");
			$parent->line(x1=>$x1,x2=>$x3,y1=>$y2,y2=>$y2,style=>$style,class=>"crossbar");
		}
	}

	return 1;
}

#-------------------------------------------------------------------------------
# multi group boxplot 
#-------------------------------------------------------------------------------
sub mboxplot
{
	my ($self,%param) = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newdata,$xval,$names) = $self->doInitAes_group(\%param);
	my @xval = @$xval;
	my @names = @$names;

	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["none"];
	my $width = $par->{width} || 0.8;
	my $size = $par->{size} || 0.9;
	my $parent = $par->{parent};

	my $factor = $par->{factor};
	my $groupN = scalar @$factor;
	my $barW = $width/$groupN; 

	$self->legend(fill=>$fill,color=>$col,shape=>[19],label=>$factor);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "boxplot($opts)";
		return 1;
	}
	
	my $xaxis = $self->{xaxis};
	my $yaxis = $self->{yaxis};

	foreach my$i( 0 .. $#names )
	{
		my $name = $names[$i];
		my $x = $xval[$i];
		my $subdata = $newdata->{$name};

		for my$j( 0 .. $#$factor)
		{
			my $group = $factor->[$j];
			my $color = loop_arr($col,$j);
			my $fill_col = loop_arr($fill,$j);

			my @val = @{$subdata->{$group}};
			my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
			my $iqr = $q3 - $q1;

			my $up = $q3 + 1.5*$iqr;
			my $low = $q1 - 1.5*$iqr;

			my ($upval,$lowval,@abnormal);
			foreach (@val)
			{
				if ($_ >= $low)
				{
					$lowval = $_;
					last;
				}
				else
				{
					push @abnormal , $_;	
				}
			}

			foreach (reverse @val)
			{
				if ($_ <= $up)
				{
					$upval = $_;
					last;
				}
				else
				{
					push @abnormal , $_;	
				}
			}

			if ($self->{conf}->{flip})
			{
				my $q3x = $self->xcoord2pos($q3);
				my $q2x = $self->xcoord2pos($q2);
				my $q1x = $self->xcoord2pos($q1);
				my $upx = $self->xcoord2pos($upval);
				my $lowx = $self->xcoord2pos($lowval);

				my $h = $q3x - $q1x;
				my $y1 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
				my $y2 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW );
				my $y3 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );
				my $w = $y3 - $y1;
			}
			else
			{
				my $q3y = $self->ycoord2pos($q3);
				my $q2y = $self->ycoord2pos($q2);
				my $q1y = $self->ycoord2pos($q1);
				my $upy = $self->ycoord2pos($upval);
				my $lowy = $self->ycoord2pos($lowval);

				my $h = ($q1y - $q3y);
				my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
				my $x2 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW);
				my $x3 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );
				my $w = ($x3-$x1);

				# box 
				$parent->rect(x=>$x1,y=>$q3y,width=>$w,height=>$h,
						style=>{stroke=>$color,fill=>$fill_col,'stroke-width'=>1});

				# median
				$parent->line(x1=>$x1,y1=>$q2y,x2=>$x3,y2=>$q2y,
						style=>{stroke=>$color,'stroke-width'=>2});

				# upper side to upper quartile
				$parent->line(x1=>$x2,x2=>$x2,y1=>$q3y,y2=>$upy,
						style=>{stroke=>$color,'stroke-width'=>1});

				# lower side to lower quartile
				$parent->line(x1=>$x2,x2=>$x2,y1=>$q1y,y2=>$lowy,
						style=>{stroke=>$color,'stroke-width'=>1});

				# abnormal vaule
				foreach my$i (@abnormal)
				{
					my $iy = $self->ycoord2pos($i);
					$parent->circle(cx=>$x2,cy=>$iy,r=>2,style=>{fill=>"#000"});
				}
			}
		}
	}
}

# boxplot
sub boxplot
{
	my ($self,%param) = @_;
	my $opts = restore_cmd(\%param);

	if (exists $param{group})
	{
		$self->mboxplot(%param);
		return 1;
	}

	my ($par,$newdata,$xval,$names) = $self->doInitAes(\%param);
	my @xval = @$xval;
	my @names = @$names;

	# default fill and col
	my $col = $#{$par->{col}} != -1 ? $par->{col} : ["#000"];
	my $fill = $par->{fill} || ["none"];
	my $width = $par->{width} || 0.6;
	my $parent = $par->{parent};
	
	$self->legend(fill=>$fill,color=>$col,shape=>[19],label=>\@names);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "boxplot($opts)";
		return 1;
	}

	my $xaxis = $self->{xaxis};
	my $yaxis = $self->{yaxis};
	foreach my$i( 0 .. $#names )
	{
		my $name = $names[$i];
		my $x = $xval[$i];
		my $color = loop_arr($col,$i);
		my $fill_col = loop_arr($fill,$i);

		my @val = @{$newdata->{$name}};
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;

		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;
		
		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}
		
		if ($self->{conf}->{flip})
		{
			my $q3x = $self->xcoord2pos($q3);
			my $q2x = $self->xcoord2pos($q2);
			my $q1x = $self->xcoord2pos($q1);
			my $upx = $self->xcoord2pos($upval);
			my $lowx = $self->xcoord2pos($lowval);
			
			my $w = $self->{yaxis}->{unit} * $width;
			my $h = ($q3x - $q1x);

			my $y2 = $self->ycoord2pos($x);
			my $y1 = $y2 - $w/2;
			my $y3 = $y2 + $w/2;

			$parent->rect(x=>$q1x,y=>$y1,width=>$h,height=>$w,
				style=>"stroke:$color;fill:$fill_col;stroke-width:1");
			
			$parent->line(x1=>$q2x,x2=>$q2x,y1=>$y1,y2=>$y3,
				style=>"stroke:$color;stroke-width:2");

			$parent->line(x1=>$q3x,x2=>$upx,y1=>$y2,y2=>$y2,
				style=>"stroke:$color;stroke-width:2");

			$parent->line(x1=>$lowx,x2=>$q1x,y1=>$y2,y2=>$y2,
				style=>"stroke:$color;stroke-width:2");

			foreach my$i (@abnormal)
			{
				my $ix = $self->xcoord2pos($i);
				$parent->circle(cx=>$ix,cy=>$y2,r=>2,style=>{fill=>"#000"});
			}
		}
		else
		{
			my $q3y = $self->ycoord2pos($q3);
			my $q2y = $self->ycoord2pos($q2);
			my $q1y = $self->ycoord2pos($q1);
			my $upy = $self->ycoord2pos($upval);
			my $lowy = $self->ycoord2pos($lowval);

			my $w = $self->{xaxis}->{unit} * $width;
			my $h = ($q1y - $q3y);

			my $x2 = $self->xcoord2pos($x);
			my $x1 = $x2 - $w/2;
			my $x3 = $x2 + $w/2;

			# box 
			$parent->rect(x=>$x1,y=>$q3y,width=>$w,height=>$h,
					style=>{stroke=>$color,fill=>$fill_col,'stroke-width'=>1});

			# median
			$parent->line(x1=>$x1,y1=>$q2y,x2=>$x3,y2=>$q2y,
					style=>{stroke=>$color,'stroke-width'=>2});

			# upper side to upper quartile
			$parent->line(x1=>$x2,x2=>$x2,y1=>$q3y,y2=>$upy,
					style=>{stroke=>$color,'stroke-width'=>1});

			# lower side to lower quartile
			$parent->line(x1=>$x2,x2=>$x2,y1=>$q1y,y2=>$lowy,
					style=>{stroke=>$color,'stroke-width'=>1});

			# abnormal vaule
			foreach my$i (@abnormal)
			{
				my $iy = $self->ycoord2pos($i);
				$parent->circle(cx=>$x2,cy=>$iy,r=>2,style=>{fill=>"#000"});
			}
		}
	}
}

# bubble
sub bubble
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @yval = @$yval;
	
	# fetch the z val
	my @zval = doFetchZval($par);

	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $level = $par->{level};
	my $parent = $par->{parent};
	my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 1;
	$self->legend(fill=>$fill,color=>$col,shape=>[1],stroke_width=>$stroke_width);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "bubble($opts)";
		return 1;
	}
	
	# the z val zoom size, turn to the raidus
	my $zoom = $par->{zoom};

	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $yval[$i];
		my $r = $zval[$i]*$zoom; 
		my ($cx,$cy) = $self->coord2pos($x,$y);

		my $color = loop_arr($col,$level->[$i]);
		my $fill_col = loop_arr($fill,$level->[$i]);
		
		$parent->circle(cx=>$cx,cy=>$cy,r=>$r,
			style=>{'stroke-width'=>$stroke_width,stroke=>$color,fill=>$fill_col});
	}

}

# lines
sub lines
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @yval = @$yval;

	# default col
	my $col = $par->{col} || ["#000"];
	my $parent = $par->{parent};
	my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;
	my $stroke_dashes = defined $par->{stroke_dashes} ? $par->{stroke_dashes} : "";
	my $level = $par->{level};
	my @levels = uniq_arr($level);
	$self->legend(color=>$col,shape=>[17],stroke_width=>$stroke_width,stroke_dashes=>$stroke_dashes);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "lines($opts)";
		return 1;
	}
	
	my ($xcor,$ycor);
	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $yval[$i];
		my $lvs = $level->[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @{$xcor->{$lvs}} , $rectx;
		push @{$ycor->{$lvs}} , $recty;
	}
	
	foreach my$i (0 .. $#levels)
	{
		my $color = loop_arr($col,$i);
		my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polyline');
		my $style = "stroke:$color;stroke-width:$stroke_width;fill:none;";
		$style.= "stroke-dasharray:$stroke_dashes;";
		my $polyline = $parent->polyline(%$points,style=>$style);
	}

}

# maplot
sub maplot
{
	my ($self,%param) = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$mval,$aval) = $self->doInitAes_maplot(\%param);
	unless ($param{draw})
	{
		push @{$self->{eval}} , "maplot($opts)";
		return 1;
	}
	
	my @xval = @$aval;
	my @yval = @$mval;

	my $fill = $par->{fill} || ["#000"];
	my $color = $par->{color} || ["#000"];
	my $shape = $par->{shape} || [1];
	my $conf = $par->{conf} || {};
	my $parent = $par->{parent};

	my ($xcor,$ycor);
	my $symid = SBV::STONE::SYMBOL::new($shape->[0],fill=>$fill->[0],color=>$color->[0]);
	foreach my$i( 0 .. $#xval )
	{
		my $x = $xval[$i];
		my $y = $yval[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @$xcor , $rectx;
		push @$ycor , $recty;
	}
	
	SBV::DRAW::points($xcor,$ycor,$symid,$conf,$parent);
}

# Ribbons
sub ribbon 
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newx,$xval,$ymax) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @ymax = @$ymax;
	
	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $opacity = $par->{opacity} || 0.5;
	my $level = $par->{level};
	my @levels = uniq_arr($level);
	my $parent = $par->{parent};
	
	$self->legend(color=>$col,fill=>$fill,shape=>[0],opacity=>$opacity);
	unless ($param{draw})
	{
		push @{$self->{eval}} , "ribbon($opts)";
		return 1;
	}
	
	#fetch the ymin val, if not set the ymin is the bottom value of y axis
	my @ymin = doFetchYmin($par);
	my $edgeY = 0;
	my $yaxis_min = $self->{yaxis}->{min};
	my $yaxis_max = $self->{yaxis}->{max};

	if ($yaxis_max < 0)
	{
		$edgeY = $yaxis_max;
	}
	elsif ($yaxis_min > 0)
	{
		$edgeY = $yaxis_min;	
	}

	my ($xcor,$ycor);
	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $ymax[$i];
		my $lvs = $level->[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @{$xcor->{$lvs}} , $rectx;
		push @{$ycor->{$lvs}} , $recty;
	}
	
	for (my$i=$#xval;$i>=0;$i--)
	{
		my $x = $newx->{$xval[$i]};
		my $y = @ymin ? $ymin[$i] : $edgeY;
		my $lvs = $level->[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @{$xcor->{$lvs}} , $rectx;
		push @{$ycor->{$lvs}} , $recty;
	}

	foreach my$i (0 .. $#levels)
	{
		my $color = loop_arr($col,$i);
		my $fill_col = loop_arr($fill,$i);

		my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polygon');
		$parent->polygon(%$points,style=>{stroke=>$color,fill=>$fill_col,'fill-opacity'=>$opacity});
	}
	
	return 1;
}

*area = \&ribbon;

# polygon 
sub polygon
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newx,$xval,$ymax) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @ymax = @$ymax;
	
	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	my $opacity = $par->{opacity} || 0.5;
	my $level = $par->{level};
	my @levels = uniq_arr($level);
	my $parent = $par->{parent};
	
	$self->legend(color=>$col,fill=>$fill,shape=>[0],opacity=>$opacity);
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "polygon($opts)";
		return 1;
	}

	my ($xcor,$ycor);
	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $ymax[$i];
		my $lvs = $level->[$i];
		my ($rectx,$recty) = $self->coord2pos($x,$y);
		push @{$xcor->{$lvs}} , $rectx;
		push @{$ycor->{$lvs}} , $recty;
	}
	
	foreach my$i (0 .. $#levels)
	{
		my $color = loop_arr($col,$i);
		my $fill_col = loop_arr($fill,$i);

		my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polygon');
		$parent->polygon(%$points,style=>{stroke=>$color,fill=>$fill_col,'fill-opacity'=>$opacity});
	}
	
	return 1;
}

# text
sub text
{
	my $self = shift;
	my %param = @_;
	my $opts = restore_cmd(\%param);

	my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
	my @xval = @$xval;
	my @yval = @$yval;
	
	# fetch the z val as the label
	my @zval = doFetchZval($par);

	# default fill and col
	my $col = $par->{col} || ["#000"];
	my $fill = $par->{fill} || ["#000"];
	$fill = ["#000"] if ($fill->[0] eq "none");
	my $level = $par->{level};
	my $parent = $par->{parent};
	# the font style 
	my $angle = $par->{angle} || 0;
	my $hjust = exists $par->{hjust} ? $par->{hjust} : 0.5;
	my $vjust = exists $par->{vjust} ? $par->{vjust} : 0.5;

	my %fstyle = ();
	$fstyle{'font-size'} = $par->{size} if (defined $par->{size});
	$fstyle{'font-family'} = $par->{family} if (defined $par->{family});
	$fstyle{'font-weight'} = $par->{weight} if (defined $par->{weight});
	$fstyle{'font-style'} = $par->{style} if (defined $par->{style});
	my $font = SBV::Font->new(\%fstyle);
	my $fontH = $font->fetch_text_height;
	
	$self->legend(fill=>$fill,color=>['none'],shape=>[64],
		fstyle=>$fstyle{'font-style'},
		fsize=>$fstyle{'font-size'},
		fweight=>$fstyle{'font-weight'},
		ffamily=>$fstyle{'font-family'});
	
	unless ($param{draw})
	{
		push @{$self->{eval}} , "text($opts)";
		return 1;
	}

	foreach my$i( 0 .. $#xval )
	{
		my $x = $newx->{$xval[$i]};
		my $y = $yval[$i];
		my $label = $zval[$i]; 
		my $fontW = $font->fetch_text_width($label);
		my $fill_col = loop_arr($fill,$level->[$i]);

		my ($cx,$cy) = $self->coord2pos($x,$y);
		my $textx = $cx - $fontW * $hjust; 
		my $texty = $cy + $fontH * $vjust;
		
		$font->setAttr({fill=>$fill_col});
		my $text = $parent->text(x=>$textx,y=>$texty,style=>$font->toStyle)->cdata($label);
		$text->setAttribute("transform","rotate($angle,$cx,$cy)") if ($angle != 0);
	}
	
}

#-------------------------------------------------------------------------------
# init data and other parameter
# for bar (stat = 'max','min','mean','sum' ....), 
# crossbar(other range graph), boxplot etc. 
# used to classify the data
#-------------------------------------------------------------------------------
sub doInitAes
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param,1);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);
	
	# x name and y name
	my $xname = $par->{x};
	my $yname = $par->{y};
	my @vars = $data->names;
	if (! defined $xname || ! defined $yname)
	{
		$xname = shift @vars;
		$yname = shift @vars;
	}
	
	# x val is as string or not
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
		
	# x val and y val
	my @xval = @{$data->{col}->{$xname}};
	my @yval = @{$data->{col}->{$yname}};
	
	my $newdata = {};
	my @names;
	for (0 .. $#xval)
	{
		push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
		push @{$newdata->{$xval[$_]}} , $yval[$_];
	}
	
	if ($xstr)
	{
		@names = @{$par->{order}} if ($par->{order});
		@xval = map { $_ + 0.5 } 0 .. $#names;
		$self->{ticktext} = \@names;
		$self->xlim(0,$#xval+1,1) unless ($param->{draw});
	}
	else
	{
		@names = sort {$a<=>$b} @names;
		@xval = @names;	
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
	}
	
	$self->ylim(min(\@yval),max(\@yval)) unless($param->{draw});
	return ($par,$newdata,\@xval,\@names);	
}

sub doInitAes_bar
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param,1);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);
	
	# x name and y name
	my $xname = $par->{x};
	my $yname = $par->{y};
	my @vars = $data->names;
	if (! defined $xname || ! defined $yname)
	{
		$xname = shift @vars;
		$yname = shift @vars;
	}
	
	# x val is as string or not
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
		
	# x val and y val
	my @xval = @{$data->{col}->{$xname}};
	my @yval = @{$data->{col}->{$yname}};
	
	my $newdata = {};
	my @names;
	for (0 .. $#xval)
	{
		push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
		push @{$newdata->{$xval[$_]}} , $yval[$_];
	}
	
	if ($xstr)
	{
		@names = @{$par->{order}} if ($par->{order});
		@xval = map { $_ + 0.5 } 0 .. $#names;
		$self->{ticktext} = \@names;
		$self->xlim(0,$#xval+1,1) unless ($param->{draw});
	}
	else
	{
		@names = sort {$a<=>$b} @names;
		@xval = @names;	
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
	}
	
	my @vals;
	my $stat = $par->{stat} || "mean";
	foreach my $x (keys %$newdata)
	{
		push @vals , fetch_y($stat,$newdata->{$x});
	}

	$self->ylim(min(\@vals),max(\@vals)) unless($param->{draw});
	return ($par,$newdata,\@xval,\@names);	
}

sub doInitAes_bar_group
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param,1);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);

	# x name and y name
	my $xname = $par->{x};
	my $yname = $par->{y};
	my @vars = $data->names;
	if (! defined $xname || ! defined $yname)
	{
		$xname = $vars[0];
		$yname = $vars[1];
	}
	
	$par->{'stat'} ||= "mean";

	# x val is as string or not
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
		
	# x val and y val
	my @xval = @{$data->{col}->{$xname}};
	my @yval = @{$data->{col}->{$yname}};
	
	my @group = exists $par->{group} ? @{$data->{col}->{$par->{group}}} : map { 1 } 0 .. $#xval;
	my @factors = uniq_arr (\@group);
	$par->{factor} = \@factors;

	my $newdata = {};
	my @names;
	for (0 .. $#xval)
	{
		push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
		push @{$newdata->{$xval[$_]}->{$group[$_]}} , $yval[$_];
	}
	
	if ($xstr)
	{
		@names = @{$par->{order}} if ($par->{order});
		@xval = map { $_ + 0.5 } 0 .. $#names;
		$self->{ticktext} = \@names;
		$self->xlim(0,$#xval+1,1) unless ($param->{draw});
	}
	else
	{
		@names = sort {$a<=>$b} @names;
		@xval = @names;	
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
	}
	
	unless ($param->{draw})
	{
		if ($param->{pileup})
		{
			my @minusVals;
			my @plusVals;
			foreach my$xitem (keys %$newdata)
			{
				my $minus_val = 0;
				my $plus_val = 0;
				foreach my$group (keys %{$newdata->{$xitem}})	
				{
					my $val = fetch_y($par->{'stat'},$newdata->{$xitem}->{$group});
					if ($val  <= 0){$minus_val += $val}else{$plus_val += $val}
				}
				push @minusVals , $minus_val;
				push @plusVals , $plus_val;
			}
			$self->ylim(min(\@minusVals),max(\@plusVals));
			my $temp = max(\@plusVals);
			if (max(\@plusVals) == 1){print "OK\n"}
		}
		else
		{
			my @vals;
			foreach my$xitem (keys %$newdata)
			{
				foreach my$group (keys %{$newdata->{$xitem}})
				{
					my $val = fetch_y($par->{'stat'},$newdata->{$xitem}->{$group});
					push @vals , $val;
				}
			}
			$self->ylim(min(\@vals),max(\@vals));
		}
		
	}

	return ($par,$newdata,\@xval,\@names);	
}

sub doInitAes_group
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param,1);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);
	
	# x name and y name
	my $xname = $par->{x};
	my $yname = $par->{y};
	my @vars = $data->names;
	if (! defined $xname || ! defined $yname)
	{
		$xname = $vars[0];
		$yname = $vars[1];
	}
	
	# x val is as string or not
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
		
	# x val and y val
	my @xval = @{$data->{col}->{$xname}};
	my @yval = @{$data->{col}->{$yname}};
	
	my @group = exists $par->{group} ? @{$data->{col}->{$par->{group}}} : map { 1 } 0 .. $#xval;
	my @factors = uniq_arr (\@group);
	$par->{factor} = \@factors;

	my $newdata = {};
	my @names;
	for (0 .. $#xval)
	{
		push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
		push @{$newdata->{$xval[$_]}->{$group[$_]}} , $yval[$_];
	}
	
	if ($xstr)
	{
		@names = @{$par->{order}} if ($par->{order});
		@xval = map { $_ + 0.5 } 0 .. $#names;
		$self->{ticktext} = \@names;
		$self->xlim(0,$#xval+1,1) unless ($param->{draw});
	}
	else
	{
		@names = sort {$a<=>$b} @names;
		@xval = @names;	
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
	}
	
	unless ($param->{draw})
	{
		$self->ylim(min(\@yval),max(\@yval));
	}
	
	return ($par,$newdata,\@xval,\@names);	
}

#-------------------------------------------------------------------------------
#  init data and other parameter 1
#  for density 
#-------------------------------------------------------------------------------
sub doInitAes_density
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param,1);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);

	my @vars = $data->names;
	my $xname = $par->{x} || $vars[0];
	
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
	my @xval = @{$data->{col}->{$xname}};
	
	my $newdata = {};
	my @names;
	for (0 .. $#xval)
	{
		push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
		$newdata->{$xval[$_]} ++;
	}

	if ($xstr)
	{
		@names = @{$par->{order}} if ($par->{order});
		@xval = map { $_ + 0.5 } 0 .. $#names;	
		$self->xlim(0,$#xval+1,1) unless ($param->{draw});
	}
	else
	{
		@names = sort {$a<=>$b} @names;
		@xval = @names;
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
	}
	
	# get the density 
	my $sum = 0;
	for my$name(@names)
	{
		ERROR('ggplot2_order_err',$name) if (! exists $newdata->{$name});
		$sum += $newdata->{$name};
	}

	for my$name(@names)
	{
		my $density = nearest 0.001 , $newdata->{$name}/$sum;
		$newdata->{$name} = $density;
	}
	
	my @densitys = values (%$newdata);
	$self->ylim(min(\@densitys),max(\@densitys)) unless ($param->{draw});

	return ($par,$newdata,\@xval,\@names); 	
}

#-------------------------------------------------------------------------------
# init data and other parameter 2
# for point, lines, bubble etc.
# used to save the position of xval(is String)
#-------------------------------------------------------------------------------
sub doInitAes2
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);
	
	my (@xval,@yval);

	# x name, y name 
	my $xname = $par->{x};
	my $yname = $par->{y};
	my @vars = $data->names;
	
	my $axis_lim = 1;
	if (ref $xname eq "ARRAY" && ref $yname eq "ARRAY")
	{
		@xval = @$xname;
		@yval = @$yname;
		$axis_lim = 0;
	}
	elsif (! defined $xname || ! defined $yname)
	{
		$xname = shift @vars;
		$yname = shift @vars;
		@xval = @{$data->{col}->{$xname}};
		@yval = @{$data->{col}->{$yname}};
	}
	elsif (-1 != aindex(\@vars,$xname) && -1 != aindex(\@vars,$yname))
	{
		@xval = @{$data->{col}->{$xname}};
		@yval = @{$data->{col}->{$yname}};
	}
	else
	{
		ERROR('no_exists_field');	
	}
	
	# x val is as string or not
	my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
	
	# turn x val to coord if x val is string
	my %newx;
	my $temp = 0.5;
	my @names;
	if ($xstr)
	{
		foreach (@xval)
		{
			if (! exists $newx{$_})
			{
				push @names , $_;
				$newx{$_} = $temp;
				$temp += 1;
			}
		}
		
		$self->{ticktext} = \@names unless ($param->{draw} || $axis_lim == 0);
		$self->xlim(0,$#names+1,1) unless ($param->{draw} || $axis_lim == 0);
	}
	else
	{
		foreach (@xval)
		{
			$newx{$_} = $_;	
		}
		$self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw} || $axis_lim == 0);
	}
	
	if (defined $par->{stat})
	{
		my $newdata = {};
		my @names;
		my @yval2;
		for (0 .. $#xval)
		{
			push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
			push @{$newdata->{$xval[$_]}} , $yval[$_];
		}

		foreach my$v(@names)
		{
			push @yval2 , ggplot2_stat($newdata->{$v},$par->{stat});	
		}

		$self->ylim(min(\@yval2),max(\@yval2)) unless ($param->{draw} || $axis_lim==0);
		return ($par,\%newx,\@names,\@yval2);
	}

	$self->ylim(min(\@yval),max(\@yval)) unless ($param->{draw} || $axis_lim==0);
	return ($par,\%newx,\@xval,\@yval);
}


# maplot 
sub doInitAes_maplot
{
	my $self = shift;
	my $param = shift;
	
	my $par = $self->localPar($param);
	my $data = $par->{data};
	ERROR('ggplot2_no_data') if (!defined $data);
	
	# x name, y name 
	my $xname = $par->{x};
	my $yname = $par->{y};
	
	my @vars = $data->names;
	if (! defined $xname || ! defined $yname)
	{
		$xname = shift @vars;
		$yname = shift @vars;
	}
		
	# x val and y val
	my @xval = @{$data->{col}->{$xname}};
	my @yval = @{$data->{col}->{$yname}};
	
	my (@mval,@aval);

	foreach my$i (0 .. $#xval)
	{
		next if ($xval[$i] == 0 || $yval[$i] == 0);
		my $m = log2($xval[$i]) - log2($yval[$i]);
		my $a = 0.5 * (log2($xval[$i]) + log2($yval[$i]));
		push @aval , $a;
		push @mval , $m;
	}
	
	$self->xlim(min(\@aval),max(\@aval)) unless ($param->{draw});
	$self->ylim(min(\@mval),max(\@mval)) unless ($param->{draw});
	return ($par,\@aval,\@mval);
}


#-------------------------------------------------------------------------------
#  fetch the z val
#  for the group/classification information or text labels
#-------------------------------------------------------------------------------
sub doFetchZval
{
	my $par = shift;
	my $data = $par->{data};
	my @vars = $data->names;
	
	my $zname = $par->{z} || $vars[2];
	return @$zname if (ref $zname eq "ARRAY");
	
	ERROR("ggplot2_no_z") if (! defined $zname);
	
	my @zval = @{$data->{col}->{$zname}};

	return @zval;
}

# fetch y min val 
# for ribbon y min 
sub doFetchYmin
{
	my $par = shift;
	my $data = $par->{data};
	my @vars = $data->names;

	my $ymin_name = $par->{ymin};
	if (! defined $ymin_name)
	{
		return ();
	}
	else
	{
		return @{$data->{col}->{$ymin_name}};	
	}
}

#-------------------------------------------------------------------------------
#  stat the array with specific method
#-------------------------------------------------------------------------------
sub ggplot2_stat
{
	my $array = shift;
	my $method = shift;

	if ($method eq "mean")
	{
		return mean($array);
	}
	elsif ($method eq "max")
	{
		return max($array);	
	}
	elsif ($method eq "min")
	{
		return min($array);	
	}
	elsif ($method eq "sum")
	{
		return sum($array);	
	}
	elsif ($method eq "var")
	{
		return var($array);	
	}
	else
	{
		ERROR('ggplot2_stat_method_err',$method);	
	}
}

# restore the cmd 
sub restore_cmd
{
	my ($val) = @_;

	if (ref $val eq "")
	{
		$val = "\'$val\'";
		return $val;
	}
	elsif (ref $val eq "ARRAY")
	{
		my @temp = map {restore_cmd($_)} @$val;
		my $line = join "," , @temp;
		return "[$line]";
	}
	elsif (ref $val eq "HASH")
	{
		my $temp = "draw=>1";
		foreach my$key(keys %$val)
		{
			$temp .= ",$key=>" . restore_cmd($val->{$key});
		}
		return $temp;
	}
	else
	{
		return $val;	
	}
}

# fetch line style
# for abline, hline, vline
sub fetch_line_style
{
	my (%par) = @_;
	my $stroke = $par{col} || "#000";
	$stroke = SBV::Colors::fetch_color($stroke);
	my $stroke_width = defined $par{stroke_width} ? $par{stroke_width} : 1;
	
	my $style = "stroke:$stroke;stroke-width:$stroke_width;";
	$style .= "stroke-dasharray:$par{stroke_dashes}" if ($par{stroke_dashes});

	return $style;
}

# 
sub fetch_range_shape
{
	my ($type) = @_;

	if ($type eq "linerange")
	{
		return 20;	
	}
	elsif ($type eq "pointrange")
	{
		return 21;	
	}
	elsif ($type eq "crossbar")
	{
		return 22;	
	}
	elsif ($type eq "errbar")
	{
		return 23;	
	}
}
